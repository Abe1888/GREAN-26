"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_next_dist_client_components_r"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ./is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment — a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation — but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(oldRouterState, newRouterState, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(newRouterState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    if (prefetchData === null) {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    const routerStateChildren = routerState[1];\n    const isPrefetchRscPartial = prefetchData[4];\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // If prefetch data is available for a segment, and it's fully static (i.e.\n    // does not contain any dynamic holes), we don't need to request it from\n    // the server.\n    if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n    isPrefetchHeadPartial && isLeafSegment) {\n        // We only have partial data from this segment. Like missing segments, we\n        // must request the full data from the server.\n        return spawnPendingTask(routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // The prefetched segment is fully static, so we don't need to request a new\n    // one from the server. Keep traversing down the tree until we reach something\n    // that requires a dynamic request.\n    const prefetchDataChildren = prefetchData[2];\n    const taskChildren = new Map();\n    const cacheNodeChildren = new Map();\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const taskChild = createCacheNodeOnNavigation(routerStateChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    const rsc = prefetchData[1];\n    const loading = prefetchData[3];\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this is a fully static segment, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head: isLeafSegment ? possiblyPartialPrefetchHead : null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((param)=>{\n        let { flightData } = param;\n        if (typeof flightData === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[2];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[2];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[1];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBS047QUFDQSxTQUFTSyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJWCxPQUFPQyxjQUFjLENBQUNTLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVAsU0FBUztJQUNiRyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtJQUNBQyx5QkFBeUI7UUFDckIsT0FBT0E7SUFDWDtJQUNBQyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtJQUNBQyxzQ0FBc0M7UUFDbEMsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMsdUdBQTZCO0FBQ3RELE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsMkdBQW1CO0FBQ2xELE1BQU1FLHdCQUF3QkYsbUJBQU9BLENBQUMsMklBQTJCO0FBQ2pFLE1BQU1HLCtCQUErQkgsbUJBQU9BLENBQUMsNkpBQW9DO0FBQ2pGLE1BQU1JLHNCQUFzQjtJQUN4QkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNkO0FBQ0EsU0FBU2pCLG1CQUFtQmtCLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUVDLFlBQVksRUFBRUMsWUFBWSxFQUFFQyxxQkFBcUIsRUFBRUMsb0JBQW9CLEVBQUVDLHdCQUF3QjtJQUN2SyxNQUFNQyxjQUFjLEVBQUU7SUFDdEIsT0FBT0MsNEJBQTRCVCxjQUFjQyxnQkFBZ0JDLGdCQUFnQixPQUFPQyxjQUFjQyxjQUFjQyx1QkFBdUJD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QUFRN0k7UUFDWjtJQUNKO0lBQ0FzSixXQUFXUCxNQUFNLEdBQUcsQ0FBQ2xDO1FBQ2pCLElBQUl5QyxXQUFXSixNQUFNLEtBQUssV0FBVztZQUNqQyxNQUFNUyxjQUFjTDtZQUNwQkssWUFBWVQsTUFBTSxHQUFHO1lBQ3JCUyxZQUFZQyxNQUFNLEdBQUcvQztZQUNyQmtDLE9BQU9sQztRQUNYO0lBQ0o7SUFDQXlDLFdBQVdELEdBQUcsR0FBR0Y7SUFDakIsT0FBT0c7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPdkosUUFBUThKLE9BQU8sS0FBSyxjQUFlLE9BQU85SixRQUFROEosT0FBTyxLQUFLLFlBQVk5SixRQUFROEosT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPOUosUUFBUThKLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktqSyxPQUFPQyxjQUFjLENBQUNDLFFBQVE4SixPQUFPLEVBQUUsY0FBYztRQUFFN0osT0FBTztJQUFLO0lBQ25FSCxPQUFPa0ssTUFBTSxDQUFDaEssUUFBUThKLE9BQU8sRUFBRTlKO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVE4SixPQUFPO0FBQ2xDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWJvcnRUYXNrOiBudWxsLFxuICAgIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0OiBudWxsLFxuICAgIHN0YXJ0UFBSTmF2aWdhdGlvbjogbnVsbCxcbiAgICB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgYWJvcnRUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0VGFzaztcbiAgICB9LFxuICAgIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0O1xuICAgIH0sXG4gICAgc3RhcnRQUFJOYXZpZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0UFBSTmF2aWdhdGlvbjtcbiAgICB9LFxuICAgIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb247XG4gICAgfVxufSk7XG5jb25zdCBfc2VnbWVudCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnRcIik7XG5jb25zdCBfbWF0Y2hzZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRjaC1zZWdtZW50c1wiKTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuY29uc3QgTVBBX05BVklHQVRJT05fVEFTSyA9IHtcbiAgICByb3V0ZTogbnVsbCxcbiAgICBub2RlOiBudWxsLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICBjaGlsZHJlbjogbnVsbFxufTtcbmZ1bmN0aW9uIHN0YXJ0UFBSTmF2aWdhdGlvbihvbGRDYWNoZU5vZGUsIG9sZFJvdXRlclN0YXRlLCBuZXdSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2hEYXRhLCBwcmVmZXRjaEhlYWQsIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCwgaXNTYW1lUGFnZU5hdmlnYXRpb24sIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCkge1xuICAgIGNvbnN0IHNlZ21lbnRQYXRoID0gW107XG4gICAgcmV0dXJuIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihvbGRDYWNoZU5vZGUsIG9sZFJvdXRlclN0YXRlLCBuZXdSb3V0ZXJTdGF0ZSwgZmFsc2UsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihvbGRDYWNoZU5vZGUsIG9sZFJvdXRlclN0YXRlLCBuZXdSb3V0ZXJTdGF0ZSwgZGlkRmluZFJvb3RMYXlvdXQsIHByZWZldGNoRGF0YSwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KSB7XG4gICAgLy8gRGlmZiB0aGUgb2xkIGFuZCBuZXcgdHJlZXMgdG8gcmV1c2UgdGhlIHNoYXJlZCBsYXlvdXRzLlxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsO1xuICAgIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAgICAgLy8gV2UncmUgY3VycmVudGx5IHRyYXZlcnNpbmcgdGhlIHBhcnQgb2YgdGhlIHRyZWUgdGhhdCB3YXMgYWxzbyBwYXJ0IG9mXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyByb3V0ZS4gSWYgd2UgZGlzY292ZXIgYSByb290IGxheW91dCwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uIFNlZSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZSBmb3IgY29udGV4dC5cbiAgICAgICAgY29uc3QgaXNSb290TGF5b3V0ID0gbmV3Um91dGVyU3RhdGVbNF0gPT09IHRydWU7XG4gICAgICAgIGlmIChpc1Jvb3RMYXlvdXQpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2hpbmcgcm9vdCBsYXlvdXQuXG4gICAgICAgICAgICBkaWRGaW5kUm9vdExheW91dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2xkUGFyYWxsZWxSb3V0ZXMgPSBvbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gICAgLy8gdGhlIG5ldyB0cmVlLlxuICAgIC8vIFRPRE86IFdlIGN1cnJlbnRseSByZXRhaW4gYWxsIHRoZSBpbmFjdGl2ZSBzZWdtZW50cyBpbmRlZmluaXRlbHksIHVudGlsXG4gICAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgICAvLyByZWx5IG9uIHRoaXMgZm9yIHBvcHN0YXRlIG5hdmlnYXRpb25zLCB3aGljaCB1cGRhdGUgdGhlIFJvdXRlciBTdGF0ZSBUcmVlXG4gICAgLy8gYnV0IGRvIG5vdCBlYWdlcmx5IHBlcmZvcm0gYSBkYXRhIGZldGNoLCBiZWNhdXNlIHRoZXkgZXhwZWN0IHRoZSBzZWdtZW50XG4gICAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgICAvLyBhcmUgbW9zdGx5IHJlYWQtb25seSwgdGhpcyBtYXkgaGFwcGVuIG9ubHkgcmFyZWx5LCBjYXVzaW5nIG1lbW9yeSB0b1xuICAgIC8vIGxlYWsuIFdlIHNob3VsZCBmaWd1cmUgb3V0IGEgYmV0dGVyIG1vZGVsIGZvciB0aGUgbGlmZXRpbWUgb2YgaW5hY3RpdmVcbiAgICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgICAvLyBsZWFraW5nIG1lbW9yeSBpbmRlZmluaXRlbHkuXG4gICAgY29uc3QgcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpO1xuICAgIC8vIEFzIHdlIGRpZmYgdGhlIHRyZWVzLCB3ZSBtYXkgc29tZXRpbWVzIG1vZGlmeSAoY29weS1vbi13cml0ZSwgbm90IG11dGF0ZSlcbiAgICAvLyB0aGUgUm91dGUgVHJlZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIOKAlCBmb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgICAvLyBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgdHJlZSwgd2UgY2xvbmUgdGhlIHJvdXRlciBzdGF0ZSBjaGlsZHJlbiBhbG9uZ1xuICAgIC8vIHRoZSByZXR1cm4gcGF0aC5cbiAgICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSB7fTtcbiAgICBsZXQgdGFza0NoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBNb3N0IG5hdmlnYXRpb25zIHJlcXVpcmUgYSByZXF1ZXN0IHRvIGZldGNoIGFkZGl0aW9uYWwgZGF0YSBmcm9tIHRoZVxuICAgIC8vIHNlcnZlciwgZWl0aGVyIGJlY2F1c2UgdGhlIGRhdGEgd2FzIG5vdCBhbHJlYWR5IHByZWZldGNoZWQsIG9yIGJlY2F1c2UgdGhlXG4gICAgLy8gdGFyZ2V0IHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZGF0YSB0aGF0IGNhbm5vdCBiZSBwcmVmZXRjaGVkLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgaWYgdGhlIHRhcmdldCByb3V0ZSBpcyBmdWxseSBzdGF0aWMsIGFuZCBpdCdzIGFscmVhZHkgY29tcGxldGVseVxuICAgIC8vIGxvYWRlZCBpbnRvIHRoZSBzZWdtZW50IGNhY2hlLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBzZXJ2ZXIgcmVxdWVzdC5cbiAgICAvL1xuICAgIC8vIFRoaXMgc3RhcnRzIG9mZiBhcyBgZmFsc2VgLCBhbmQgaXMgc2V0IHRvIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGNoaWxkXG4gICAgLy8gcm91dGVzIHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICAgIGxldCBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gZmFsc2U7XG4gICAgLy8gQXMgd2UgdHJhdmVyc2UgdGhlIGNoaWxkcmVuLCB3ZSdsbCBjb25zdHJ1Y3QgYSBGbGlnaHRSb3V0ZXJTdGF0ZSB0aGF0IGNhblxuICAgIC8vIGJlIHNlbnQgdG8gdGhlIHNlcnZlciB0byByZXF1ZXN0IHRoZSBkeW5hbWljIGRhdGEuIElmIGl0IHR1cm5zIG91dCB0aGF0XG4gICAgLy8gbm90aGluZyBpbiB0aGUgc3VidHJlZSBpcyBkeW5hbWljIChpLmUuIG5lZWRzRHluYW1pY1JlcXVlc3QgaXMgZmFsc2UgYXQgdGhlXG4gICAgLy8gZW5kKSwgdGhlbiB0aGlzIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgIC8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBvcHRpbWl6ZSB0aGUgZm9ybWF0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUgdG8gb25seVxuICAgIC8vIGluY2x1ZGUgcGF0aHMgdGhhdCBhcmUgZHluYW1pYy4gSW5zdGVhZCBvZiByZXVzaW5nIHRoZVxuICAgIC8vIEZsaWdodFJvdXRlclN0YXRlIHR5cGUuXG4gICAgbGV0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuID0ge307XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIG5ld1JvdXRlclN0YXRlQ2hpbGRyZW4pe1xuICAgICAgICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkID0gbmV3Um91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgb2xkUm91dGVyU3RhdGVDaGlsZCA9IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQgPSBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbCA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldIDogbnVsbDtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudENoaWxkID0gbmV3Um91dGVyU3RhdGVDaGlsZFswXTtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudFBhdGhDaGlsZCA9IHNlZ21lbnRQYXRoLmNvbmNhdChbXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICAgICAgbmV3U2VnbWVudENoaWxkXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShuZXdTZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPSBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgPyBvbGRSb3V0ZXJTdGF0ZUNoaWxkWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkU2VnbWVudE1hcENoaWxkLmdldChuZXdTZWdtZW50S2V5Q2hpbGQpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdGFza0NoaWxkO1xuICAgICAgICBpZiAobmV3U2VnbWVudENoaWxkID09PSBfc2VnbWVudC5ERUZBVUxUX1NFR01FTlRfS0VZKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFub3RoZXIga2luZCBvZiBsZWFmIHNlZ21lbnQg4oCUIGEgZGVmYXVsdCByb3V0ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHJvdXRlcyBoYXZlIHNwZWNpYWwgYmVoYXZpb3IuIFdoZW4gdGhlcmUncyBubyBtYXRjaGluZyBzZWdtZW50XG4gICAgICAgICAgICAvLyBmb3IgYSBwYXJhbGxlbCByb3V0ZSwgTmV4dC5qcyBwcmVzZXJ2ZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudFxuICAgICAgICAgICAgLy8gZHVyaW5nIGEgY2xpZW50IG5hdmlnYXRpb24g4oCUIGJ1dCBub3QgZm9yIGluaXRpYWwgcmVuZGVyLiBUaGUgc2VydmVyXG4gICAgICAgICAgICAvLyBsZWF2ZXMgaXQgdG8gdGhlIGNsaWVudCB0byBhY2NvdW50IGZvciB0aGlzLiBTbyB3ZSBuZWVkIHRvIGhhbmRsZVxuICAgICAgICAgICAgLy8gaXQgaGVyZS5cbiAgICAgICAgICAgIGlmIChvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSB0aGUgZXhpc3RpbmcgUm91dGVyIFN0YXRlIGZvciB0aGlzIHNlZ21lbnQuIFdlIHNwYXduIGEgXCJ0YXNrXCJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZnVsZmlsbGVkIGFuZCB3b24ndCBiZSBhZmZlY3RlZCBieSB0aGUgZHluYW1pYyByZXNwb25zZS5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blJldXNlZFRhc2sob2xkUm91dGVyU3RhdGVDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gY3VycmVudGx5IGFjdGl2ZSBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShvbGRSb3V0ZXJTdGF0ZUNoaWxkLCBuZXdSb3V0ZXJTdGF0ZUNoaWxkLCBkaWRGaW5kUm9vdExheW91dCwgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIG5ld1NlZ21lbnRQYXRoQ2hpbGQsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTYW1lUGFnZU5hdmlnYXRpb24gJiYgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHBhZ2Ugc2VnbWVudC5cbiAgICAgICAgLy8gVE9ETzogV2UncmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgaG93IHdlIGRvIHRoaXMgY2hlY2suIFNvbWUgcGxhY2VzXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IHN0YXJ0cyB3aXRoIFBBR0VfU0VHTUVOVF9LRVksIGJ1dCBtb3N0IHNlZW0gdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYW55IGFueSBjaGlsZHJlbiwgd2hpY2ggaXMgd2h5IEknbSBkb2luZyBpdCBoZXJlLiBXZVxuICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgZW5jb2RlIGFuIGVtcHR5IGNoaWxkcmVuIHNldCBhcyBgbnVsbGAgdGhvdWdoLiBFaXRoZXJcbiAgICAgICAgLy8gd2F5LCB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgY2hlY2tzIHRvIGJlIGNvbnNpc3RlbnQuXG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1JvdXRlclN0YXRlQ2hpbGRbMV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIG5hdmlnYXRpb25zIHRvIHRoZSBleGFjdCBzYW1lIFVSTCBhcyB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gbG9jYXRpb24uIEl0J3MgYSBjb21tb24gVUkgcGF0dGVybiBmb3IgYXBwcyB0byByZWZyZXNoIHdoZW4geW91IGNsaWNrIGFcbiAgICAgICAgICAgIC8vIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGFnZS4gU28gd2hlbiB0aGlzIGhhcHBlbnMsIHdlIHJlZnJlc2ggdGhlIGR5bmFtaWNcbiAgICAgICAgICAgIC8vIGRhdGEgaW4gdGhlIHBhZ2Ugc2VnbWVudHMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYXBwbHkgaWYgdGhlIGFueSBwYXJ0IG9mIHRoZSBoYXNoIG9yIHNlYXJjaFxuICAgICAgICAgICAgLy8gcXVlcnkgaGFzIGNoYW5nZWQuIFRoaXMgbWlnaHQgZmVlbCBhIGJpdCB3ZWlyZCBidXQgaXQgbWFrZXMgbW9yZSBzZW5zZVxuICAgICAgICAgICAgLy8gd2hlbiB5b3UgY29uc2lkZXIgdGhhdCB0aGUgd2F5IHRvIHRyaWdnZXIgdGhpcyBiZWhhdmlvciBpcyB0byBjbGlja1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgbGluayBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgcmVmcmVzaCB0aGUgKmVudGlyZSogcm91dGUgd2hlbiB0aGlzIGNhc2VcbiAgICAgICAgICAgIC8vIG9jY3Vycywgbm90IGp1c3QgdGhlIHBhZ2Ugc2VnbWVudHMuIEVzc2VudGlhbGx5IHRyZWF0aW5nIGl0IHRoZSBzYW1lIGFzXG4gICAgICAgICAgICAvLyBhIHJlZnJlc2goKSB0cmlnZ2VyZWQgYnkgYW4gYWN0aW9uLCB3aGljaCBpcyB0aGUgbW9yZSBleHBsaWNpdCB3YXkgb2ZcbiAgICAgICAgICAgIC8vIG1vZGVsaW5nIHRoZSBVSSBwYXR0ZXJuIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCB0aGlzIG9ubHkgcmVmcmVzaGVzIHRoZSBkeW5hbWljIGRhdGEsIG5vdCBzdGF0aWMvXG4gICAgICAgICAgICAvLyBjYWNoZWQgZGF0YS4gSWYgdGhlIHBhZ2Ugc2VnbWVudCBpcyBmdWxseSBzdGF0aWMgYW5kIHByZWZldGNoZWQsIHRoZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCBpcyBza2lwcGVkLiAoVGhpcyBpcyBhbHNvIGhvdyByZWZyZXNoKCkgd29ya3MuKVxuICAgICAgICAgICAgdGFza0NoaWxkID0gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUob2xkUm91dGVyU3RhdGVDaGlsZCwgbmV3Um91dGVyU3RhdGVDaGlsZCwgZGlkRmluZFJvb3RMYXlvdXQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBuZXdTZWdtZW50UGF0aENoaWxkLCBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBvbGRTZWdtZW50Q2hpbGQgIT09IHVuZGVmaW5lZCAmJiAoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShuZXdTZWdtZW50Q2hpbGQsIG9sZFNlZ21lbnRDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkICYmIG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VnbWVudCBleGlzdHMgaW4gYm90aCB0aGUgb2xkIGFuZCBuZXcgdHJlZXMuIFJlY3Vyc2l2ZWx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24ob2xkQ2FjaGVOb2RlQ2hpbGQsIG9sZFJvdXRlclN0YXRlQ2hpbGQsIG5ld1JvdXRlclN0YXRlQ2hpbGQsIGRpZEZpbmRSb290TGF5b3V0LCBwcmVmZXRjaERhdGFDaGlsZCwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uLCBuZXdTZWdtZW50UGF0aENoaWxkLCBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGV4aXN0aW5nIENhY2hlIE5vZGUgZm9yIHRoaXMgc2VnbWVudC4gU3dpdGNoIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShvbGRSb3V0ZXJTdGF0ZUNoaWxkLCBuZXdSb3V0ZXJTdGF0ZUNoaWxkLCBkaWRGaW5kUm9vdExheW91dCwgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIG5ld1NlZ21lbnRQYXRoQ2hpbGQsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHRyZWUuIFN3aXRjaCB0byB0aGUgXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICAgICAgdGFza0NoaWxkID0gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUob2xkUm91dGVyU3RhdGVDaGlsZCwgbmV3Um91dGVyU3RhdGVDaGlsZCwgZGlkRmluZFJvb3RMYXlvdXQsIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsIHByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBuZXdTZWdtZW50UGF0aENoaWxkLCBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSB1cCB0aGUgY2hpbGQgdGFza3MuXG4gICAgICAgICAgICBpZiAodGFza0NoaWxkLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gT25lIG9mIHRoZSBjaGlsZCB0YXNrcyBkaXNjb3ZlcmVkIGEgY2hhbmdlIHRvIHRoZSByb290IGxheW91dC5cbiAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGVseSB1bndpbmQgZnJvbSB0aGlzIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1QQV9OQVZJR0FUSU9OX1RBU0s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB0YXNrQ2hpbGQubm9kZTtcbiAgICAgICAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGQgdHJlZSdzIHJvdXRlIHN0YXRlIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgLy8gcm91dGUgc2VudCBieSB0aGUgc2VydmVyLiBXZSBuZWVkIHRvIGNsb25lIGl0IGFzIHdlIHRyYXZlcnNlIGJhY2sgdXBcbiAgICAgICAgICAgIC8vIHRoZSB0cmVlLlxuICAgICAgICAgICAgY29uc3QgdGFza0NoaWxkUm91dGUgPSB0YXNrQ2hpbGQucm91dGU7XG4gICAgICAgICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgPSB0YXNrQ2hpbGQuZHluYW1pY1JlcXVlc3RUcmVlO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSBjaGlsZCB0cmVlIGlzIGR5bmFtaWMuXG4gICAgICAgICAgICAgICAgbmVlZHNEeW5hbWljUmVxdWVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSB0YXNrQ2hpbGRSb3V0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBjaGlsZCBkaWRuJ3QgY2hhbmdlLiBXZSBjYW4gdXNlIHRoZSBwcmVmZXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZDtcbiAgICAgICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5vIG5ldyB0YXNrcyB3ZXJlIHNwYXduZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG9sZENhY2hlTm9kZS5yc2MsXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgYXJlbid0IHVwZGF0aW5nIHRoZSBwcmVmZXRjaFJzYyBmaWVsZCwgc2luY2UgdGhpcyBub2RlXG4gICAgICAgIC8vIGlzIGFscmVhZHkgcGFydCBvZiB0aGUgY3VycmVudCB0cmVlLCBiZWNhdXNlIGl0IHdvdWxkIGJlIHdlaXJkIGZvclxuICAgICAgICAvLyBwcmVmZXRjaCBkYXRhIHRvIGJlIG5ld2VyIHRoYW4gdGhlIGZpbmFsIGRhdGEuIEl0IHByb2JhYmx5IHdvbid0IGV2ZXIgYmVcbiAgICAgICAgLy8gb2JzZXJ2YWJsZSBhbnl3YXksIGJ1dCBpdCBjb3VsZCBoYXBwZW4gaWYgdGhlIHNlZ21lbnQgaXMgdW5tb3VudGVkIHRoZW5cbiAgICAgICAgLy8gbW91bnRlZCBhZ2FpbiwgYmVjYXVzZSBMYXlvdXRSb3V0ZXIgd2lsbCBtb21lbnRhcmlseSBzd2l0Y2ggdG8gcmVuZGVyaW5nXG4gICAgICAgIC8vIHByZWZldGNoUnNjLCB2aWEgdXNlRGVmZXJyZWRWYWx1ZS5cbiAgICAgICAgcHJlZmV0Y2hSc2M6IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgaGVhZDogb2xkQ2FjaGVOb2RlLmhlYWQsXG4gICAgICAgIHByZWZldGNoSGVhZDogb2xkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgbG9hZGluZzogb2xkQ2FjaGVOb2RlLmxvYWRpbmcsXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgY2xvbmVkIGV4Y2VwdCBmb3IgdGhlIGNoaWxkcmVuLCB3aGljaCB3ZSBjb21wdXRlZCBhYm92ZS5cbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IHByZWZldGNoUGFyYWxsZWxSb3V0ZXNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFJldHVybiBhIGNsb25lZCBjb3B5IG9mIHRoZSByb3V0ZXIgc3RhdGUgd2l0aCB1cGRhdGVkIGNoaWxkcmVuLlxuICAgICAgICByb3V0ZTogcGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbihuZXdSb3V0ZXJTdGF0ZSwgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4pLFxuICAgICAgICBub2RlOiBuZXdDYWNoZU5vZGUsXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdCA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4obmV3Um91dGVyU3RhdGUsIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuKSA6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW5cbiAgICB9O1xufVxuZnVuY3Rpb24gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUob2xkUm91dGVyU3RhdGUsIG5ld1JvdXRlclN0YXRlLCBkaWRGaW5kUm9vdExheW91dCwgcHJlZmV0Y2hEYXRhLCBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQsIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCwgc2VnbWVudFBhdGgsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCkge1xuICAgIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAgICAgLy8gVGhlIHJvdXRlIHRyZWUgY2hhbmdlZCBiZWZvcmUgd2UgcmVhY2hlZCBhIGxheW91dC4gKFRoZSBoaWdoZXN0LWxldmVsXG4gICAgICAgIC8vIGxheW91dCBpbiBhIHJvdXRlIHRyZWUgaXMgcmVmZXJyZWQgdG8gYXMgdGhlIFwicm9vdFwiIGxheW91dC4pIFRoaXMgY291bGRcbiAgICAgICAgLy8gbWVhbiB0aGF0IHdlJ3JlIG5hdmlnYXRpbmcgYmV0d2VlbiB0d28gZGlmZmVyZW50IHJvb3QgbGF5b3V0cy4gV2hlbiB0aGlzXG4gICAgICAgIC8vIGhhcHBlbnMsIHdlIHBlcmZvcm0gYSBmdWxsLXBhZ2UgKE1QQS1zdHlsZSkgbmF2aWdhdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGFsZ29yaXRobSBmb3IgZGVjaWRpbmcgd2hlcmUgdG8gc3RhcnQgcmVuZGVyaW5nIGEgcm91dGVcbiAgICAgICAgLy8gKGkuZS4gdGhlIG9uZSBwZXJmb3JtZWQgaW4gb3JkZXIgdG8gcmVhY2ggdGhpcyBmdW5jdGlvbikgaXMgc3RyaWN0ZXJcbiAgICAgICAgLy8gdGhhbiB0aGUgb25lIHVzZWQgdG8gZGV0ZWN0IGEgY2hhbmdlIGluIHRoZSByb290IGxheW91dC4gU28ganVzdCBiZWNhdXNlXG4gICAgICAgIC8vIHdlJ3JlIHJlLXJlbmRlcmluZyBhIHNlZ21lbnQgb3V0c2lkZSBvZiB0aGUgcm9vdCBsYXlvdXQgZG9lcyBub3QgbWVhbiB3ZVxuICAgICAgICAvLyBzaG91bGQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTcGVjaWZpY2FsbHksIHdlIGhhbmRsZSBkeW5hbWljIHBhcmFtZXRlcnMgZGlmZmVyZW50bHk6IHR3byBzZWdtZW50cyBhcmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCB0aGUgc2FtZSBldmVuIGlmIHRoZWlyIHBhcmFtZXRlciB2YWx1ZXMgYXJlIGRpZmZlcmVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVmZXIgdG8gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IGZvciBkZXRhaWxzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugb25seSBoYXZlIHRvIHBlcmZvcm0gdGhpcyBleHRyYSB0cmF2ZXJzYWwgaWYgd2UgZGlkbid0XG4gICAgICAgIC8vIGFscmVhZHkgZGlzY292ZXIgYSByb290IGxheW91dCBpbiB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IGlzIHVuY2hhbmdlZC5cbiAgICAgICAgLy8gSW4gdGhlIGNvbW1vbiBjYXNlLCB0aGlzIGJyYW5jaCBpcyBza2lwcGVkIGNvbXBsZXRlbHkuXG4gICAgICAgIGlmIChvbGRSb3V0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8ICgwLCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0LmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkob2xkUm91dGVyU3RhdGUsIG5ld1JvdXRlclN0YXRlKSkge1xuICAgICAgICAgICAgLy8gVGhlIHJvb3QgbGF5b3V0IGNoYW5nZWQuIFBlcmZvcm0gYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24obmV3Um91dGVyU3RhdGUsIHByZWZldGNoRGF0YSwgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIHNlZ21lbnRQYXRoLCBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KSB7XG4gICAgLy8gU2FtZSB0cmF2ZXJzYWwgYXMgdXBkYXRlQ2FjaGVOb2RlTmF2aWdhdGlvbiwgYnV0IHdlIHN3aXRjaCB0byB0aGlzIHBhdGhcbiAgICAvLyBvbmNlIHdlIHJlYWNoIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIG5vdCBpbiB0aGUgcHJldmlvdXMgcm91dGUuIFdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBkaWZmIGFnYWluc3QgdGhlIG9sZCB0cmVlLCB3ZSBqdXN0IG5lZWQgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBpZiAocHJlZmV0Y2hEYXRhID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gcHJlZmV0Y2ggZm9yIHRoaXMgc2VnbWVudC4gRXZlcnl0aGluZyBmcm9tIHRoaXMgcG9pbnQgd2lsbCBiZVxuICAgICAgICAvLyByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIHRoZXJlIGFyZSBzdGF0aWMgY2hpbGRyZW4gYmVsb3cgaXQuXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlcm1pbmFsIHRhc2sgbm9kZSB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5XG4gICAgICAgIC8vIHNlcnZlciByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIHNwYXduUGVuZGluZ1Rhc2socm91dGVyU3RhdGUsIG51bGwsIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdO1xuICAgIGNvbnN0IGlzUHJlZmV0Y2hSc2NQYXJ0aWFsID0gcHJlZmV0Y2hEYXRhWzRdO1xuICAgIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gICAgY29uc3QgaXNMZWFmU2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlQ2hpbGRyZW4pLmxlbmd0aCA9PT0gMDtcbiAgICAvLyBJZiBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSBmb3IgYSBzZWdtZW50LCBhbmQgaXQncyBmdWxseSBzdGF0aWMgKGkuZS5cbiAgICAvLyBkb2VzIG5vdCBjb250YWluIGFueSBkeW5hbWljIGhvbGVzKSwgd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGl0IGZyb21cbiAgICAvLyB0aGUgc2VydmVyLlxuICAgIGlmICgvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBkYXRhIGlzIHBhcnRpYWxcbiAgICBpc1ByZWZldGNoUnNjUGFydGlhbCB8fCAvLyBDaGVjayBpZiB0aGUgaGVhZCBpcyBwYXJ0aWFsIChvbmx5IHJlbGV2YW50IGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQpXG4gICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsICYmIGlzTGVhZlNlZ21lbnQpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHBhcnRpYWwgZGF0YSBmcm9tIHRoaXMgc2VnbWVudC4gTGlrZSBtaXNzaW5nIHNlZ21lbnRzLCB3ZVxuICAgICAgICAvLyBtdXN0IHJlcXVlc3QgdGhlIGZ1bGwgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KTtcbiAgICB9XG4gICAgLy8gVGhlIHByZWZldGNoZWQgc2VnbWVudCBpcyBmdWxseSBzdGF0aWMsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVxdWVzdCBhIG5ld1xuICAgIC8vIG9uZSBmcm9tIHRoZSBzZXJ2ZXIuIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0cmVlIHVudGlsIHdlIHJlYWNoIHNvbWV0aGluZ1xuICAgIC8vIHRoYXQgcmVxdWlyZXMgYSBkeW5hbWljIHJlcXVlc3QuXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGFbMl07XG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIGxldCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbiA9IHt9O1xuICAgIGxldCBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gZmFsc2U7XG4gICAgaWYgKGlzTGVhZlNlZ21lbnQpIHtcbiAgICAgICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAgICAgLy8gYSByZXN1bHQgYXJyYXkuIFRoaXMgaXMgdXNlZCBieSB0aGUgTGF5b3V0Um91dGVyIHRvIHNjcm9sbCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyBuZXcgcGFnZXMgYXJlIHZpc2libGUgYWZ0ZXIgYSBuYXZpZ2F0aW9uLlxuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYW4gYXJyYXkuIFdlIGFscmVhZHkgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgcGF0aCB3aGVuXG4gICAgICAgIC8vIGFjY2Vzc2luZyB0aGUgU2VnbWVudCBDYWNoZSwgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBvbmUuXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbil7XG4gICAgICAgICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkID0gcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkID0gcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGwgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudFBhdGhDaGlsZCA9IHNlZ21lbnRQYXRoLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgICAgICAgICAgICBzZWdtZW50Q2hpbGRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkoc2VnbWVudENoaWxkKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IGNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihyb3V0ZXJTdGF0ZUNoaWxkLCBwcmVmZXRjaERhdGFDaGlsZCwgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIHNlZ21lbnRQYXRoQ2hpbGQsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCk7XG4gICAgICAgICAgICB0YXNrQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIHRhc2tDaGlsZCk7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCA9IHRhc2tDaGlsZC5keW5hbWljUmVxdWVzdFRyZWU7XG4gICAgICAgICAgICBpZiAoZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIGNoaWxkIHRyZWUgaXMgZHluYW1pYy5cbiAgICAgICAgICAgICAgICBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHJvdXRlclN0YXRlQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHRhc2tDaGlsZC5ub2RlO1xuICAgICAgICAgICAgaWYgKG5ld0NhY2hlTm9kZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIG5ld1NlZ21lbnRNYXBDaGlsZC5zZXQoc2VnbWVudEtleUNoaWxkLCBuZXdDYWNoZU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgY2FjaGVOb2RlQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcnNjID0gcHJlZmV0Y2hEYXRhWzFdO1xuICAgIGNvbnN0IGxvYWRpbmcgPSBwcmVmZXRjaERhdGFbM107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmV3IHJvdXRlIHRyZWUsIHVubGlrZSB0aGVcbiAgICAgICAgLy8gYHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbmAgcGF0aCwgdGhlIHJvdXRlciBzdGF0ZSBvbiB0aGUgY2hpbGRyZW5cbiAgICAgICAgLy8gdGFza3MgaXMgYWx3YXlzIHRoZSBzYW1lIGFzIHRoZSByb3V0ZXIgc3RhdGUgd2UgcGFzcyBpbi4gU28gd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyB0byBjbG9uZS9tb2RpZnkgaXQuXG4gICAgICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcbiAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgZnVsbHkgc3RhdGljIHNlZ21lbnQsIHdlIGRvbid0IG5lZWQgdG8gdXNlIHRoZVxuICAgICAgICAgICAgLy8gYHByZWZldGNoUnNjYCBmaWVsZC5cbiAgICAgICAgICAgIHJzYyxcbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgaGVhZDogaXNMZWFmU2VnbWVudCA/IHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCA6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IGNhY2hlTm9kZUNoaWxkcmVuXG4gICAgICAgIH0sXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdCA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4ocm91dGVyU3RhdGUsIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuKSA6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW5cbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbihiYXNlUm91dGVyU3RhdGUsIG5ld0NoaWxkcmVuKSB7XG4gICAgY29uc3QgY2xvbmUgPSBbXG4gICAgICAgIGJhc2VSb3V0ZXJTdGF0ZVswXSxcbiAgICAgICAgbmV3Q2hpbGRyZW5cbiAgICBdO1xuICAgIC8vIEJhc2VkIG9uIGVxdWl2YWxlbnQgbG9naWMgaW4gYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUsIGJ1dCBzaG91bGRcbiAgICAvLyBjb25maXJtIHdoZXRoZXIgd2UgbmVlZCB0byBjb3B5IGFsbCBvZiB0aGVzZSBmaWVsZHMuIE5vdCBzdXJlIHRoZSBzZXJ2ZXJcbiAgICAvLyBldmVyIHNlbmRzLCBlLmcuIHRoZSByZWZldGNoIG1hcmtlci5cbiAgICBpZiAoMiBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICAgICAgY2xvbmVbMl0gPSBiYXNlUm91dGVyU3RhdGVbMl07XG4gICAgfVxuICAgIGlmICgzIGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgICAgICBjbG9uZVszXSA9IGJhc2VSb3V0ZXJTdGF0ZVszXTtcbiAgICB9XG4gICAgaWYgKDQgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgICAgIGNsb25lWzRdID0gYmFzZVJvdXRlclN0YXRlWzRdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBzcGF3blBlbmRpbmdUYXNrKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KSB7XG4gICAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgIC8vIENsb25lIHRoZSBwcmVmZXRjaGVkIHJvdXRlIHRyZWUgYW5kIHRoZSBgcmVmZXRjaGAgbWFya2VyIHRvIGl0LiBXZSdsbCBzZW5kXG4gICAgLy8gdGhpcyB0byB0aGUgc2VydmVyIHNvIGl0IGtub3dzIHdoZXJlIHRvIHN0YXJ0IHJlbmRlcmluZy5cbiAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWUgPSBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKHJvdXRlclN0YXRlLCByb3V0ZXJTdGF0ZVsxXSk7XG4gICAgZHluYW1pY1JlcXVlc3RUcmVlWzNdID0gJ3JlZmV0Y2gnO1xuICAgIGNvbnN0IG5ld1Rhc2sgPSB7XG4gICAgICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcbiAgICAgICAgLy8gQ29ycmVzcG9uZHMgdG8gdGhlIHBhcnQgb2YgdGhlIHJvdXRlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyLlxuICAgICAgICBub2RlOiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlLCBwcmVmZXRjaERhdGEsIHByZWZldGNoSGVhZCwgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLCBzZWdtZW50UGF0aCwgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0KSxcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGlzIG5vbi1udWxsLCBhbmQgaXQgZ2V0cyBwcm9wYWdhdGVkIHVwIHRocm91Z2ggdGhlIHBhcmVudFxuICAgICAgICAvLyB0YXNrcywgdGhlIHJvb3QgdGFzayB3aWxsIGtub3cgdGhhdCBpdCBuZWVkcyB0byBwZXJmb3JtIGEgc2VydmVyIHJlcXVlc3QuXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZSxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBuZXdUYXNrO1xufVxuZnVuY3Rpb24gc3Bhd25SZXVzZWRUYXNrKHJldXNlZFJvdXRlclN0YXRlKSB7XG4gICAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHJldXNlcyBhbiBleGlzdGluZyBzZWdtZW50LCBlLmcuIHdoZW4gcmV1c2luZ1xuICAgIC8vIHRoZSBjdXJyZW50IGFjdGl2ZSBzZWdtZW50IGluIHBsYWNlIG9mIGEgZGVmYXVsdCByb3V0ZS5cbiAgICByZXR1cm4ge1xuICAgICAgICByb3V0ZTogcmV1c2VkUm91dGVyU3RhdGUsXG4gICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QodGFzaywgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgcmVzcG9uc2VQcm9taXNlLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBmbGlnaHREYXRhIH0gPSBwYXJhbTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gSGFwcGVucyB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGAuIFdlIHNob3VsZG4ndFxuICAgICAgICAgICAgLy8gZ2V0IGhlcmUgYmVjYXVzZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgdGhpcyBkdXJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBwcmVmZXRjaC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgY29uc3QgeyBzZWdtZW50UGF0aCwgdHJlZTogc2VydmVyUm91dGVyU3RhdGUsIHNlZWREYXRhOiBkeW5hbWljRGF0YSwgaGVhZDogZHluYW1pY0hlYWQgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhO1xuICAgICAgICAgICAgaWYgKCFkeW5hbWljRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayh0YXNrLCBzZWdtZW50UGF0aCwgc2VydmVyUm91dGVyU3RhdGUsIGR5bmFtaWNEYXRhLCBkeW5hbWljSGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHRoYXQgd2UndmUgZXhoYXVzdGVkIGFsbCB0aGUgZGF0YSB3ZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIsIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nIHBlbmRpbmcgdGFza3MgaW4gdGhlIHRyZWUsIGFib3J0IHRoZW0gbm93LlxuICAgICAgICAvLyBJZiB0aGVyZSdzIGFueSBtaXNzaW5nIGRhdGEsIGl0IHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2guXG4gICAgICAgIGFib3J0VGFzayh0YXNrLCBudWxsKTtcbiAgICB9LCAoZXJyb3IpPT57XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGR1cmluZyByZW5kZXJcbiAgICAgICAgYWJvcnRUYXNrKHRhc2ssIGVycm9yKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2socm9vdFRhc2ssIHNlZ21lbnRQYXRoLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKSB7XG4gICAgLy8gVGhlIGRhdGEgc2VudCBieSB0aGUgc2VydmVyIHJlcHJlc2VudHMgb25seSBhIHN1YnRyZWUgb2YgdGhlIGFwcC4gV2UgbmVlZFxuICAgIC8vIHRvIGZpbmQgdGhlIHBhcnQgb2YgdGhlIHRhc2sgdHJlZSB0aGF0IG1hdGNoZXMgdGhlIHNlcnZlciByZXNwb25zZSwgYW5kXG4gICAgLy8gZnVsZmlsbCBpdCB1c2luZyB0aGUgZHluYW1pYyBkYXRhLlxuICAgIC8vXG4gICAgLy8gc2VnbWVudFBhdGggcmVwcmVzZW50cyB0aGUgcGFyZW50IHBhdGggb2Ygc3VidHJlZS4gSXQncyBhIHJlcGVhdGluZyBwYXR0ZXJuXG4gICAgLy8gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAgIC8vXG4gICAgLy8gICBbc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgLi4uXVxuICAgIC8vXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwYXRoIGFuZCBmaW5pc2ggYW55IHRhc2tzIHRoYXQgbWF0Y2ggdGhpcyBwYXlsb2FkLlxuICAgIGxldCB0YXNrID0gcm9vdFRhc2s7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKXtcbiAgICAgICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleSA9IHNlZ21lbnRQYXRoW2ldO1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdO1xuICAgICAgICBjb25zdCB0YXNrQ2hpbGRyZW4gPSB0YXNrLmNoaWxkcmVuO1xuICAgICAgICBpZiAodGFza0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrQ2hpbGQgPSB0YXNrQ2hpbGRyZW4uZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICAgICAgaWYgKHRhc2tDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF07XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHNlZ21lbnQsIHRhc2tTZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoIGZvciB0aGlzIHRhc2suIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0YXNrIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSB0YXNrQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gRXhpdC4gV2Ugd29uJ3RcbiAgICAgICAgLy8gYWJvcnQgdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgICAgICAvLyBmdWxmaWxsIGl0IChzZWUgbG9vcCBpbiBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCkuIFdlIG9ubHkgYWJvcnQgdGFza3NcbiAgICAgICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkKHRhc2ssIHNlcnZlclJvdXRlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpO1xufVxuZnVuY3Rpb24gZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkKHRhc2ssIHNlcnZlclJvdXRlclN0YXRlLCBkeW5hbWljRGF0YSwgZHluYW1pY0hlYWQpIHtcbiAgICBpZiAodGFzay5keW5hbWljUmVxdWVzdFRyZWUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRXZlcnl0aGluZyBpbiB0aGlzIHN1YnRyZWUgaXMgYWxyZWFkeSBjb21wbGV0ZS4gQmFpbCBvdXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZHluYW1pY0RhdGEgbWF5IHJlcHJlc2VudCBhIGxhcmdlciBzdWJ0cmVlIHRoYW4gdGhlIHRhc2suIEJlZm9yZSB3ZSBjYW5cbiAgICAvLyBmaW5pc2ggdGhlIHRhc2ssIHdlIG5lZWQgdG8gbGluZSB0aGVtIHVwLlxuICAgIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW47XG4gICAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGU7XG4gICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBsZWFmIG5vZGUgb2YgdGhlIHBlbmRpbmcgdGFzay4gVGhlIHNlcnZlciBkYXRhIHRyZWVcbiAgICAgICAgLy8gbGluZXMgdXAgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBXZSBjYW4gbm93IHN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKHRhc2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKHRhc2tOb2RlLCB0YXNrLnJvdXRlLCBzZXJ2ZXJSb3V0ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHRhc2sgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgICAgICAgdGFzay5keW5hbWljUmVxdWVzdFRyZWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlIHNlcnZlciByZXR1cm5lZCBtb3JlIGRhdGEgdGhhbiB3ZSBuZWVkIHRvIGZpbmlzaCB0aGUgdGFzay4gU2tpcCBvdmVyXG4gICAgLy8gdGhlIGV4dHJhIHNlZ21lbnRzIHVudGlsIHdlIHJlYWNoIHRoZSBsZWFmIHRhc2sgbm9kZS5cbiAgICBjb25zdCBzZXJ2ZXJDaGlsZHJlbiA9IHNlcnZlclJvdXRlclN0YXRlWzFdO1xuICAgIGNvbnN0IGR5bmFtaWNEYXRhQ2hpbGRyZW4gPSBkeW5hbWljRGF0YVsyXTtcbiAgICBmb3IoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBzZXJ2ZXJSb3V0ZXJTdGF0ZSl7XG4gICAgICAgIGNvbnN0IHNlcnZlclJvdXRlclN0YXRlQ2hpbGQgPSBzZXJ2ZXJDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgZHluYW1pY0RhdGFDaGlsZCA9IGR5bmFtaWNEYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF07XG4gICAgICAgICAgICBpZiAoKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkoc2VydmVyUm91dGVyU3RhdGVDaGlsZFswXSwgdGFza1NlZ21lbnQpICYmIGR5bmFtaWNEYXRhQ2hpbGQgIT09IG51bGwgJiYgZHluYW1pY0RhdGFDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSBtYXRjaCBmb3IgdGhpcyB0YXNrLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdGFzayB0cmVlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQodGFza0NoaWxkLCBzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkLCBkeW5hbWljRGF0YUNoaWxkLCBkeW5hbWljSGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gV2Ugd29uJ3QgYWJvcnRcbiAgICAvLyB0aGUgdGFzaywgdGhvdWdoLCBiZWNhdXNlIGEgZGlmZmVyZW50IEZsaWdodERhdGFQYXRoIG1heSBiZSBhYmxlIHRvXG4gICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZSwgcHJlZmV0Y2hEYXRhLCBwcmVmZXRjaEhlYWQsIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCwgc2VnbWVudFBhdGgsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCkge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZHJlbiA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsyXSA6IG51bGw7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pe1xuICAgICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkID0gcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQgPSBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbCA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudFBhdGhDaGlsZCA9IHNlZ21lbnRQYXRoLmNvbmNhdChbXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICAgICAgc2VnbWVudENoaWxkXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGVDaGlsZCwgcHJlZmV0Y2hEYXRhQ2hpbGQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwcmVmZXRjaERhdGFDaGlsZCwgcHJlZmV0Y2hIZWFkLCBpc1ByZWZldGNoSGVhZFBhcnRpYWwsIHNlZ21lbnRQYXRoQ2hpbGQsIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCk7XG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKTtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZCk7XG4gICAgfVxuICAgIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gICAgY29uc3QgaXNMZWFmU2VnbWVudCA9IHBhcmFsbGVsUm91dGVzLnNpemUgPT09IDA7XG4gICAgaWYgKGlzTGVhZlNlZ21lbnQpIHtcbiAgICAgICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAgICAgLy8gYSByZXN1bHQgYXJyYXkuIFRoaXMgaXMgdXNlZCBieSB0aGUgTGF5b3V0Um91dGVyIHRvIHNjcm9sbCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyBuZXcgcGFnZXMgYXJlIHZpc2libGUgYWZ0ZXIgYSBuYXZpZ2F0aW9uLlxuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYW4gYXJyYXkuIFdlIGFscmVhZHkgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgcGF0aCB3aGVuXG4gICAgICAgIC8vIGFjY2Vzc2luZyB0aGUgU2VnbWVudCBDYWNoZSwgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBvbmUuXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGw7XG4gICAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogcGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgIHByZWZldGNoUnNjOiBtYXliZVByZWZldGNoUnNjICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoUnNjIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBpc0xlYWZTZWdtZW50ID8gcHJlZmV0Y2hIZWFkIDogW1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVE9ETzogVGVjaG5pY2FsbHksIGEgbG9hZGluZyBib3VuZGFyeSBjb3VsZCBjb250YWluIGR5bmFtaWMgZGF0YS4gV2UgbXVzdFxuICAgICAgICAvLyBoYXZlIHNlcGFyYXRlIGBsb2FkaW5nYCBhbmQgYHByZWZldGNoTG9hZGluZ2AgZmllbGRzIHRvIGhhbmRsZSB0aGlzLCBsaWtlXG4gICAgICAgIC8vIHdlIGRvIGZvciB0aGUgc2VnbWVudCBkYXRhIGFuZCBoZWFkLlxuICAgICAgICBsb2FkaW5nOiBtYXliZVByZWZldGNoTG9hZGluZyAhPT0gdW5kZWZpbmVkID8gbWF5YmVQcmVmZXRjaExvYWRpbmcgOiBudWxsLFxuICAgICAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBwcm9taXNlLiBUaGlzIHdpbGwgYmUgZnVsZmlsbGVkIG9uY2UgdGhlIGR5bmFtaWNcbiAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICByc2M6IGNyZWF0ZURlZmVycmVkUnNjKCksXG4gICAgICAgIGhlYWQ6IGlzTGVhZlNlZ21lbnQgPyBjcmVhdGVEZWZlcnJlZFJzYygpIDogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKGNhY2hlTm9kZSwgdGFza1N0YXRlLCBzZXJ2ZXJTdGF0ZSwgZHluYW1pY0RhdGEsIGR5bmFtaWNIZWFkKSB7XG4gICAgLy8gV3JpdGVzIGEgZHluYW1pYyByZXNwb25zZSBpbnRvIGFuIGV4aXN0aW5nIENhY2hlIE5vZGUgdHJlZS4gVGhpcyBkb2VzIF9ub3RfXG4gICAgLy8gY3JlYXRlIGEgbmV3IHRyZWUsIGl0IHVwZGF0ZXMgdGhlIGV4aXN0aW5nIHRyZWUgaW4tcGxhY2UuIFNvIGl0IG11c3QgZm9sbG93XG4gICAgLy8gdGhlIFN1c3BlbnNlIHJ1bGVzIG9mIGNhY2hlIHNhZmV0eSDigJQgaXQgY2FuIHJlc29sdmUgcGVuZGluZyBwcm9taXNlcywgYnV0XG4gICAgLy8gaXQgY2Fubm90IG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhLiBJdCBjYW4gYWRkIHNlZ21lbnRzIHRvIHRoZSB0cmVlIChiZWNhdXNlXG4gICAgLy8gYSBtaXNzaW5nIHNlZ21lbnQgd2lsbCBjYXVzZSB0aGUgbGF5b3V0IHJvdXRlciB0byBzdXNwZW5kKS5cbiAgICAvLyBidXQgaXQgY2Fubm90IGRlbGV0ZSB0aGVtLlxuICAgIC8vXG4gICAgLy8gV2UgbXVzdCByZXNvbHZlIGV2ZXJ5IHByb21pc2UgaW4gdGhlIHRyZWUsIG9yIGVsc2UgaXQgd2lsbCBzdXNwZW5kXG4gICAgLy8gaW5kZWZpbml0ZWx5LiBJZiB3ZSBkaWQgbm90IHJlY2VpdmUgZGF0YSBmb3IgYSBzZWdtZW50LCB3ZSB3aWxsIHJlc29sdmUgaXRzXG4gICAgLy8gZGF0YSBwcm9taXNlIHRvIGBudWxsYCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgIGNvbnN0IHRhc2tTdGF0ZUNoaWxkcmVuID0gdGFza1N0YXRlWzFdO1xuICAgIGNvbnN0IHNlcnZlclN0YXRlQ2hpbGRyZW4gPSBzZXJ2ZXJTdGF0ZVsxXTtcbiAgICBjb25zdCBkYXRhQ2hpbGRyZW4gPSBkeW5hbWljRGF0YVsyXTtcbiAgICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgd2UgdHJhdmVyc2UgdGhlIHRyZWUgd2l0aCAodGFza1N0YXRlKSBpcyB0aGUgc2FtZSBvbmVcbiAgICAvLyB0aGF0IHdlIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gVGhhdCB3YXkgd2UncmUgc3VyZVxuICAgIC8vIHRvIHJlc29sdmUgYWxsIHRoZSBwZW5kaW5nIHByb21pc2VzLlxuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzO1xuICAgIGZvcihsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiB0YXNrU3RhdGVDaGlsZHJlbil7XG4gICAgICAgIGNvbnN0IHRhc2tTdGF0ZUNoaWxkID0gdGFza1N0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlcnZlclN0YXRlQ2hpbGQgPSBzZXJ2ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBkYXRhQ2hpbGQgPSBkYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICAgICAgY29uc3QgdGFza1NlZ21lbnRDaGlsZCA9IHRhc2tTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudEtleUNoaWxkID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkodGFza1NlZ21lbnRDaGlsZCk7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID0gc2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWQgPyBzZWdtZW50TWFwQ2hpbGQuZ2V0KHRhc2tTZWdtZW50S2V5Q2hpbGQpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHNlcnZlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiAoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KSh0YXNrU2VnbWVudENoaWxkLCBzZXJ2ZXJTdGF0ZUNoaWxkWzBdKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBkYXRhQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaGFwcHkgcGF0aC4gUmVjdXJzaXZlbHkgdXBkYXRlIGFsbCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoY2FjaGVOb2RlQ2hpbGQsIHRhc2tTdGF0ZUNoaWxkLCBzZXJ2ZXJTdGF0ZUNoaWxkLCBkYXRhQ2hpbGQsIGR5bmFtaWNIZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2VydmVyIG5ldmVyIHJldHVybmVkIGRhdGEgZm9yIHRoaXMgc2VnbWVudC4gVHJpZ2dlciBhIGxhenlcbiAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2ggZHVyaW5nIHJlbmRlci4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhlIFJvdXRlIFRyZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBTZWVkIERhdGEgdHJlZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAvLyBzaGFwZSB3aGVuIHBhcnQgb2YgdGhlIHNhbWUgc2VydmVyIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFza1N0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgICAgICAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2tTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVzcG9uc2UgbWF0Y2hlcyB3aGF0IHdhcyBleHBlY3RlZCB0byByZWNlaXZlLCBidXQgdGhlcmUnc1xuICAgICAgICAvLyBubyBtYXRjaGluZyBDYWNoZSBOb2RlIGluIHRoZSB0YXNrIHRyZWUuIFRoaXMgaXMgYSBidWcgaW4gdGhlXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIGJlY2F1c2Ugd2Ugc2hvdWxkIGhhdmUgY3JlYXRlZCBhIG5vZGUgZm9yIGV2ZXJ5XG4gICAgICAgIC8vIHNlZ21lbnQgaW4gdGhlIHRyZWUgdGhhdCdzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhc2suXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRvIGZ1bGZpbGwgdGhlIGRlZmVycmVkIFJTQyBwcm9taXNlXG4gICAgLy8gb24gdGhlIENhY2hlIE5vZGUuXG4gICAgY29uc3QgcnNjID0gY2FjaGVOb2RlLnJzYztcbiAgICBjb25zdCBkeW5hbWljU2VnbWVudERhdGEgPSBkeW5hbWljRGF0YVsxXTtcbiAgICBpZiAocnNjID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsYXp5IGNhY2hlIG5vZGUuIFdlIGNhbiBvdmVyd3JpdGUgaXQuIFRoaXMgaXMgb25seSBzYWZlXG4gICAgICAgIC8vIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBMYXlvdXRSb3V0ZXIgc3VzcGVuZHMgaWYgYHJzY2AgaXMgYG51bGxgLlxuICAgICAgICBjYWNoZU5vZGUucnNjID0gZHluYW1pY1NlZ21lbnREYXRhO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJzYyhyc2MpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkZWZlcnJlZCBSU0MgcHJvbWlzZS4gV2UgY2FuIGZ1bGZpbGwgaXQgd2l0aCB0aGUgZGF0YSB3ZSBqdXN0XG4gICAgICAgIC8vIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gSWYgaXQgd2FzIGFscmVhZHkgcmVzb2x2ZWQgYnkgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gbmF2aWdhdGlvbiwgdGhlbiB0aGlzIGRvZXMgbm90aGluZyBiZWNhdXNlIHdlIGNhbid0IG92ZXJ3cml0ZSBkYXRhLlxuICAgICAgICByc2MucmVzb2x2ZShkeW5hbWljU2VnbWVudERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYSBkZWZlcnJlZCBSU0MgcHJvbWlzZSwgbm9yIGlzIGl0IGVtcHR5LCBzbyBpdCBtdXN0IGhhdmVcbiAgICAvLyBiZWVuIHBvcHVsYXRlZCBieSBhIGRpZmZlcmVudCBuYXZpZ2F0aW9uLiBXZSBtdXN0IG5vdCBvdmVyd3JpdGUgaXQuXG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAgIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZHluYW1pYyBoZWFkIGZyb21cbiAgICAvLyB0aGUgc2VydmVyLlxuICAgIGNvbnN0IGhlYWQgPSBjYWNoZU5vZGUuaGVhZDtcbiAgICBpZiAoaXNEZWZlcnJlZFJzYyhoZWFkKSkge1xuICAgICAgICBoZWFkLnJlc29sdmUoZHluYW1pY0hlYWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFib3J0VGFzayh0YXNrLCBlcnJvcikge1xuICAgIGNvbnN0IGNhY2hlTm9kZSA9IHRhc2subm9kZTtcbiAgICBpZiAoY2FjaGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaW5kaWNhdGVzIHRoZSB0YXNrIGlzIGFscmVhZHkgY29tcGxldGUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlbjtcbiAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJlYWNoZWQgdGhlIGxlYWYgdGFzayBub2RlLiBUaGlzIGlzIHRoZSByb290IG9mIGEgcGVuZGluZyBjYWNoZVxuICAgICAgICAvLyBub2RlIHRyZWUuXG4gICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrLnJvdXRlLCBjYWNoZU5vZGUsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVybWVkaWF0ZSB0YXNrIG5vZGUuIEtlZXAgdHJhdmVyc2luZyB1bnRpbCB3ZSByZWFjaCBhXG4gICAgICAgIC8vIHRhc2sgbm9kZSB3aXRoIG5vIGNoaWxkcmVuLiBUaGF0IHdpbGwgYmUgdGhlIHJvb3Qgb2YgdGhlIGNhY2hlIG5vZGUgdHJlZVxuICAgICAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLlxuICAgICAgICBmb3IgKGNvbnN0IHRhc2tDaGlsZCBvZiB0YXNrQ2hpbGRyZW4udmFsdWVzKCkpe1xuICAgICAgICAgICAgYWJvcnRUYXNrKHRhc2tDaGlsZCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHRhc2sgaXMgbm93IGNvbXBsZXRlLlxuICAgIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZSwgY2FjaGVOb2RlLCBlcnJvcikge1xuICAgIC8vIEZvciBldmVyeSBwZW5kaW5nIHNlZ21lbnQgaW4gdGhlIHRyZWUsIHJlc29sdmUgaXRzIGByc2NgIHByb21pc2UgdG8gYG51bGxgXG4gICAgLy8gdG8gdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAvL1xuICAgIC8vIE9yLCBpZiBhbiBlcnJvciBvYmplY3QgaXMgcHJvdmlkZWQsIGl0IHdpbGwgZXJyb3IgaW5zdGVhZC5cbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV07XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgZm9yKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pe1xuICAgICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkID0gcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XTtcbiAgICAgICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgICAgICBpZiAoc2VnbWVudE1hcENoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnRDaGlsZCk7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID0gc2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpO1xuICAgICAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlJ3JlIHRyYXZlcnNpbmcgdGhlIHNhbWUgdHJlZSB0aGF0IHdhc1xuICAgICAgICAvLyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgY2FjaGUgbm9kZXMgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZS5yc2M7XG4gICAgaWYgKGlzRGVmZXJyZWRSc2MocnNjKSkge1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgcnNjLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBkdXJpbmcgcmVuZGVyaW5nLlxuICAgICAgICAgICAgcnNjLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gICAgLy8gYSBwZW5kaW5nIHByb21pc2UgdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZC4gSWYgYW4gZXJyb3Igd2FzIHByb3ZpZGVkLCB3ZVxuICAgIC8vIHdpbGwgbm90IHJlc29sdmUgaXQgd2l0aCBhbiBlcnJvciwgc2luY2UgdGhpcyBpcyByZW5kZXJlZCBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIHRoZSBhcHAuIFdlIHdhbnQgdGhlIHNlZ21lbnQgdG8gZXJyb3IsIG5vdCB0aGUgZW50aXJlIGFwcC5cbiAgICBjb25zdCBoZWFkID0gY2FjaGVOb2RlLmhlYWQ7XG4gICAgaWYgKGlzRGVmZXJyZWRSc2MoaGVhZCkpIHtcbiAgICAgICAgaGVhZC5yZXNvbHZlKG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbihvbGRDYWNoZU5vZGUsIHJvdXRlclN0YXRlKSB7XG4gICAgLy8gQSBwb3BzdGF0ZSBuYXZpZ2F0aW9uIHJlYWRzIGRhdGEgZnJvbSB0aGUgbG9jYWwgY2FjaGUuIEl0IGRvZXMgbm90IGlzc3VlXG4gICAgLy8gbmV3IG5ldHdvcmsgcmVxdWVzdHMgKHVubGVzcyB0aGUgY2FjaGUgZW50cmllcyBoYXZlIGJlZW4gZXZpY3RlZCkuIFNvLCB3ZVxuICAgIC8vIHVwZGF0ZSB0aGUgY2FjaGUgdG8gZHJvcCB0aGUgcHJlZmV0Y2ggZGF0YSBmb3IgYW55IHNlZ21lbnQgd2hvc2UgZHluYW1pY1xuICAgIC8vIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXMgcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFJcbiAgICAvLyBzdGF0ZSBkdXJpbmcgYSBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gY2xvbmVzIHRoZSBlbnRpcmUgY2FjaGUgbm9kZSB0cmVlIGFuZCBzZXRzIHRoZSBgcHJlZmV0Y2hSc2NgXG4gICAgLy8gZmllbGQgdG8gYG51bGxgIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZC4gV2UgY2FuJ3QgbXV0YXRlIHRoZSBub2RlXG4gICAgLy8gaW4gcGxhY2UgYmVjYXVzZSB0aGlzIGlzIGEgY29uY3VycmVudCBkYXRhIHN0cnVjdHVyZS5cbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV07XG4gICAgY29uc3Qgb2xkUGFyYWxsZWxSb3V0ZXMgPSBvbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXM7XG4gICAgY29uc3QgbmV3UGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKG9sZFBhcmFsbGVsUm91dGVzKTtcbiAgICBmb3IobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbil7XG4gICAgICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldO1xuICAgICAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdO1xuICAgICAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShzZWdtZW50Q2hpbGQpO1xuICAgICAgICBjb25zdCBvbGRTZWdtZW50TWFwQ2hpbGQgPSBvbGRQYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgICAgIGlmIChvbGRTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPSBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZCk7XG4gICAgICAgICAgICBpZiAob2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKG9sZENhY2hlTm9kZUNoaWxkLCByb3V0ZXJTdGF0ZUNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQgPSBuZXcgTWFwKG9sZFNlZ21lbnRNYXBDaGlsZCk7XG4gICAgICAgICAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBPbmx5IHNob3cgcHJlZmV0Y2hlZCBkYXRhIGlmIHRoZSBkeW5hbWljIGRhdGEgaXMgc3RpbGwgcGVuZGluZy5cbiAgICAvL1xuICAgIC8vIFRlaG5pY2FsbHksIHdoYXQgd2UncmUgYWN0dWFsbHkgY2hlY2tpbmcgaXMgd2hldGhlciB0aGUgZHluYW1pYyBuZXR3b3JrXG4gICAgLy8gcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLiBCdXQgc2luY2UgaXQncyBhIHN0cmVhbWluZyByZXNwb25zZSwgdGhpcyBkb2VzIG5vdFxuICAgIC8vIG1lYW4gdGhhdCBhbGwgdGhlIGR5bmFtaWMgZGF0YSBoYXMgZnVsbHkgc3RyZWFtZWQgaW4uIEl0IGp1c3QgbWVhbnMgdGhhdFxuICAgIC8vIF9zb21lXyBvZiB0aGUgZHluYW1pYyBkYXRhIHdhcyByZWNlaXZlZC4gQnV0IGFzIGEgaGV1cmlzdGljLCB3ZSBhc3N1bWUgdGhhdFxuICAgIC8vIHRoZSByZXN0IGR5bmFtaWMgZGF0YSB3aWxsIHN0cmVhbSBpbiBxdWlja2x5LCBzbyBpdCdzIHN0aWxsIGJldHRlciB0byBza2lwXG4gICAgLy8gdGhlIHByZWZldGNoIHN0YXRlLlxuICAgIGNvbnN0IHJzYyA9IG9sZENhY2hlTm9kZS5yc2M7XG4gICAgY29uc3Qgc2hvdWxkVXNlUHJlZmV0Y2ggPSBpc0RlZmVycmVkUnNjKHJzYykgJiYgcnNjLnN0YXR1cyA9PT0gJ3BlbmRpbmcnO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2MsXG4gICAgICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IHNob3VsZFVzZVByZWZldGNoID8gb2xkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF0sXG4gICAgICAgIHByZWZldGNoUnNjOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyA6IG51bGwsXG4gICAgICAgIGxvYWRpbmc6IG9sZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGNsb25lZCBjaGlsZHJlbiB3ZSBjb21wdXRlZCBhYm92ZVxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3UGFyYWxsZWxSb3V0ZXNcbiAgICB9O1xufVxuY29uc3QgREVGRVJSRUQgPSBTeW1ib2woKTtcbi8vIFRoaXMgdHlwZSBleGlzdHMgdG8gZGlzdGluZ3Vpc2ggYSBEZWZlcnJlZFJzYyBmcm9tIGEgRmxpZ2h0IHByb21pc2UuIEl0J3MgYVxuLy8gY29tcHJvbWlzZSB0byBhdm9pZCBhZGRpbmcgYW4gZXh0cmEgZmllbGQgb24gZXZlcnkgQ2FjaGUgTm9kZSwgd2hpY2ggd291bGQgYmVcbi8vIGF3a3dhcmQgYmVjYXVzZSB0aGUgcHJlLVBQUiBwYXJ0cyBvZiBjb2RlYmFzZSB3b3VsZCBuZWVkIHRvIGFjY291bnQgZm9yIGl0LFxuLy8gdG9vLiBXZSBjYW4gcmVtb3ZlIGl0IG9uY2UgdHlwZSBDYWNoZSBOb2RlIHR5cGUgaXMgbW9yZSBzZXR0bGVkLlxuZnVuY3Rpb24gaXNEZWZlcnJlZFJzYyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50YWcgPT09IERFRkVSUkVEO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRSc2MoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHJlamVjdDtcbiAgICBjb25zdCBwZW5kaW5nUnNjID0gbmV3IFByb21pc2UoKHJlcywgcmVqKT0+e1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcGVuZGluZ1JzYy5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgcGVuZGluZ1JzYy5yZXNvbHZlID0gKHZhbHVlKT0+e1xuICAgICAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZnVsZmlsbGVkUnNjID0gcGVuZGluZ1JzYztcbiAgICAgICAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIGZ1bGZpbGxlZFJzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBlbmRpbmdSc2MucmVqZWN0ID0gKGVycm9yKT0+e1xuICAgICAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ZWRSc2MgPSBwZW5kaW5nUnNjO1xuICAgICAgICAgICAgcmVqZWN0ZWRSc2Muc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHJlamVjdGVkUnNjLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRDtcbiAgICByZXR1cm4gcGVuZGluZ1JzYztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHByLW5hdmlnYXRpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0Iiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3NlZ21lbnQiLCJyZXF1aXJlIiwiX21hdGNoc2VnbWVudHMiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiTVBBX05BVklHQVRJT05fVEFTSyIsInJvdXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImNoaWxkcmVuIiwib2xkQ2FjaGVOb2RlIiwib2xkUm91dGVyU3RhdGUiLCJuZXdSb3V0ZXJTdGF0ZSIsInByZWZldGNoRGF0YSIsInByZWZldGNoSGVhZCIsImlzUHJlZmV0Y2hIZWFkUGFydGlhbCIsImlzU2FtZVBhZ2VOYXZpZ2F0aW9uIiwic2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0Iiwic2VnbWVudFBhdGgiLCJ1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24iLCJkaWRGaW5kUm9vdExheW91dCIsIm9sZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwicHJlZmV0Y2hEYXRhQ2hpbGRyZW4iLCJpc1Jvb3RMYXlvdXQiLCJvbGRQYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGVzIiwicHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyIsIk1hcCIsInBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwidGFza0NoaWxkcmVuIiwibmVlZHNEeW5hbWljUmVxdWVzdCIsImR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuIiwicGFyYWxsZWxSb3V0ZUtleSIsIm5ld1JvdXRlclN0YXRlQ2hpbGQiLCJvbGRSb3V0ZXJTdGF0ZUNoaWxkIiwib2xkU2VnbWVudE1hcENoaWxkIiwicHJlZmV0Y2hEYXRhQ2hpbGQiLCJuZXdTZWdtZW50Q2hpbGQiLCJuZXdTZWdtZW50UGF0aENoaWxkIiwiY29uY2F0IiwibmV3U2VnbWVudEtleUNoaWxkIiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJvbGRTZWdtZW50Q2hpbGQiLCJ1bmRlZmluZWQiLCJvbGRDYWNoZU5vZGVDaGlsZCIsInRhc2tDaGlsZCIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJzcGF3blJldXNlZFRhc2siLCJiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZSIsImtleXMiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJzZXQiLCJuZXdDYWNoZU5vZGVDaGlsZCIsIm5ld1NlZ21lbnRNYXBDaGlsZCIsInRhc2tDaGlsZFJvdXRlIiwiZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQiLCJuZXdDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsImxvYWRpbmciLCJwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuIiwicG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uIiwicm91dGVyU3RhdGUiLCJzcGF3blBlbmRpbmdUYXNrIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsImlzUHJlZmV0Y2hSc2NQYXJ0aWFsIiwiaXNMZWFmU2VnbWVudCIsImNhY2hlTm9kZUNoaWxkcmVuIiwicHVzaCIsInJvdXRlclN0YXRlQ2hpbGQiLCJzZWdtZW50Q2hpbGQiLCJzZWdtZW50UGF0aENoaWxkIiwic2VnbWVudEtleUNoaWxkIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsIm5ld1Rhc2siLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZSIsInNlcnZlclJvdXRlclN0YXRlIiwic2VlZERhdGEiLCJkeW5hbWljRGF0YSIsImR5bmFtaWNIZWFkIiwid3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayIsImVycm9yIiwicm9vdFRhc2siLCJpIiwic2VnbWVudCIsInRhc2tTZWdtZW50IiwiZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkIiwidGFza05vZGUiLCJmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlIiwic2VydmVyQ2hpbGRyZW4iLCJkeW5hbWljRGF0YUNoaWxkcmVuIiwic2VydmVyUm91dGVyU3RhdGVDaGlsZCIsImR5bmFtaWNEYXRhQ2hpbGQiLCJzaXplIiwibWF5YmVQcmVmZXRjaFJzYyIsIm1heWJlUHJlZmV0Y2hMb2FkaW5nIiwiY3JlYXRlRGVmZXJyZWRSc2MiLCJjYWNoZU5vZGUiLCJ0YXNrU3RhdGUiLCJzZXJ2ZXJTdGF0ZSIsInRhc2tTdGF0ZUNoaWxkcmVuIiwic2VydmVyU3RhdGVDaGlsZHJlbiIsImRhdGFDaGlsZHJlbiIsInRhc2tTdGF0ZUNoaWxkIiwic2VydmVyU3RhdGVDaGlsZCIsImRhdGFDaGlsZCIsInNlZ21lbnRNYXBDaGlsZCIsInRhc2tTZWdtZW50Q2hpbGQiLCJ0YXNrU2VnbWVudEtleUNoaWxkIiwiY2FjaGVOb2RlQ2hpbGQiLCJhYm9ydFBlbmRpbmdDYWNoZU5vZGUiLCJkeW5hbWljU2VnbWVudERhdGEiLCJpc0RlZmVycmVkUnNjIiwicmVzb2x2ZSIsInZhbHVlcyIsInJlamVjdCIsIm5ld1BhcmFsbGVsUm91dGVzIiwic2hvdWxkVXNlUHJlZmV0Y2giLCJzdGF0dXMiLCJERUZFUlJFRCIsIlN5bWJvbCIsInRhZyIsInBlbmRpbmdSc2MiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiZnVsZmlsbGVkUnNjIiwicmVqZWN0ZWRSc2MiLCJyZWFzb24iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FLTjtBQUNBLFNBQVNLLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlYLE9BQU9DLGNBQWMsQ0FBQ1MsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRUCxTQUFTO0lBQ2JHLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0lBQ0FDLGdDQUFnQztRQUM1QixPQUFPQTtJQUNYO0lBQ0FDLCtCQUErQjtRQUMzQixPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyx1QkFBdUJDLG1CQUFPQSxDQUFDLHVJQUF5QjtBQUM5RCxNQUFNQyxzQkFBc0JELG1CQUFPQSxDQUFDLHFJQUF3QjtBQUM1RCxNQUFNRSxtQkFBbUJGLG1CQUFPQSxDQUFDLCtJQUE2QjtBQUM5RCxNQUFNRyxnQ0FBZ0M7QUFDdEM7Ozs7OztDQU1DLEdBQUcsU0FBU0MsMkJBQTJCQyxHQUFHLEVBQUVDLG1CQUFtQixFQUFFQyxNQUFNO0lBQ3BFLGdGQUFnRjtJQUNoRixnRkFBZ0Y7SUFDaEYsa0JBQWtCO0lBQ2xCLElBQUlDLGtCQUFrQkgsSUFBSUksUUFBUTtJQUNsQyw0RkFBNEY7SUFDNUYsOERBQThEO0lBQzlELHFGQUFxRjtJQUNyRixnRkFBZ0Y7SUFDaEYscURBQXFEO0lBQ3JELElBQUlILHFCQUFxQjtRQUNyQiwwRUFBMEU7UUFDMUUsa0ZBQWtGO1FBQ2xGLDRDQUE0QztRQUM1Q0UsbUJBQW1CSCxJQUFJSyxN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QWMsQ0FBQ0MsUUFBUXFHLE9BQU8sRUFBRSxjQUFjO1FBQUVwRyxPQUFPO0lBQUs7SUFDbkVILE9BQU95RyxNQUFNLENBQUN2RyxRQUFRcUcsT0FBTyxFQUFFckc7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUXFHLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcmVmZXRjaC1jYWNoZS11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFNUQVRJQ19TVEFMRVRJTUVfTVM6IG51bGwsXG4gICAgY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5OiBudWxsLFxuICAgIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5OiBudWxsLFxuICAgIHBydW5lUHJlZmV0Y2hDYWNoZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBTVEFUSUNfU1RBTEVUSU1FX01TOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRJQ19TVEFMRVRJTUVfTVM7XG4gICAgfSxcbiAgICBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5O1xuICAgIH0sXG4gICAgZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnk7XG4gICAgfSxcbiAgICBwcnVuZVByZWZldGNoQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJ1bmVQcmVmZXRjaENhY2hlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfcHJlZmV0Y2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlclwiKTtcbmNvbnN0IElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSID0gJyUnO1xuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUga2V5IGZvciB0aGUgcm91dGVyIHByZWZldGNoIGNhY2hlXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYmVpbmcgbmF2aWdhdGVkIHRvXG4gKiBAcGFyYW0gbmV4dFVybCAtIGFuIGludGVybmFsIFVSTCwgcHJpbWFyaWx5IHVzZWQgZm9yIGhhbmRsaW5nIHJld3JpdGVzLiBEZWZhdWx0cyB0byAnLycuXG4gKiBAcmV0dXJuIFRoZSBnZW5lcmF0ZWQgcHJlZmV0Y2ggY2FjaGUga2V5LlxuICovIGZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwgaW5jbHVkZVNlYXJjaFBhcmFtcywgcHJlZml4KSB7XG4gICAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgICAvLyBzZWFyY2ggcGFyYW1zIHNvIHRoYXQgbXVsdGlwbGUgVVJMcyB3aXRoIHRoZSBzYW1lIHNlYXJjaCBwYXJhbWV0ZXIgY2FuIHJlLXVzZVxuICAgIC8vIGxvYWRpbmcgc3RhdGVzLlxuICAgIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWU7XG4gICAgLy8gUlNDIHJlc3BvbnNlcyBjYW4gZGlmZmVyIGJhc2VkIG9uIHNlYXJjaCBwYXJhbXMsIHNwZWNpZmljYWxseSBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBhcmVuJ3RcbiAgICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAgIC8vIEluIHRoZSBhdXRvIGNhc2UsIHNpbmNlIGxvYWRpbmcuanMgJiBsYXlvdXQuanMgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gc2VhcmNoIHBhcmFtcyxcbiAgICAvLyB3ZSBjYW4gc2FmZWx5IHJlLXVzZSB0aGF0IGNhY2hlIGVudHJ5LiBCdXQgZm9yIGZ1bGwgcHJlZmV0Y2hlcywgd2Ugc2hvdWxkIG5vdFxuICAgIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gICAgaWYgKGluY2x1ZGVTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAgICAgLy8gYXMgd2UnbGwgYmUgZ2V0dGluZyBiYWNrIGEgZnVsbCByZXNwb25zZS4gVGhlIHNlcnZlciBtaWdodCBoYXZlIHJlYWQgdGhlIHNlYXJjaFxuICAgICAgICAvLyBwYXJhbXMgd2hlbiBnZW5lcmF0aW5nIHRoZSBmdWxsIHJlc3BvbnNlLlxuICAgICAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaDtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIElOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSICsgcGF0aG5hbWVGcm9tVXJsO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQsIG5leHRVcmwpIHtcbiAgICByZXR1cm4gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwodXJsLCBraW5kID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMLCBuZXh0VXJsKTtcbn1cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeSh1cmwsIGtpbmQsIG5leHRVcmwsIHByZWZldGNoQ2FjaGUsIGFsbG93QWxpYXNpbmcpIHtcbiAgICBpZiAoa2luZCA9PT0gdm9pZCAwKSBraW5kID0gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuVEVNUE9SQVJZO1xuICAgIC8vIFdlIGZpcnN0IGNoZWNrIGlmIHRoZXJlJ3MgYSBtb3JlIHNwZWNpZmljIGludGVyY2VwdGlvbiByb3V0ZSBwcmVmZXRjaCBlbnRyeVxuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHdlIGRldGVjdCBhIHByZWZldGNoIHRoYXQgY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHByZWZpeCBpdCB3aXRoIG5leHRVcmwgKHNlZSBgY3JlYXRlUHJlZmV0Y2hDYWNoZUtleWApXG4gICAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gICAgZm9yIChjb25zdCBtYXliZU5leHRVcmwgb2YgW1xuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBudWxsXG4gICAgXSl7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwgdHJ1ZSwgbWF5YmVOZXh0VXJsKTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXlXaXRob3V0UGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwodXJsLCBmYWxzZSwgbWF5YmVOZXh0VXJsKTtcbiAgICAgICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5VG9Vc2UgPSB1cmwuc2VhcmNoID8gY2FjaGVLZXlXaXRoUGFyYW1zIDogY2FjaGVLZXlXaXRob3V0UGFyYW1zO1xuICAgICAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlUb1VzZSk7XG4gICAgICAgIGlmIChleGlzdGluZ0VudHJ5ICYmIGFsbG93QWxpYXNpbmcpIHtcbiAgICAgICAgICAgIC8vIFdlIGtub3cgd2UncmUgcmV0dXJuaW5nIGFuIGFsaWFzZWQgZW50cnkgd2hlbiB0aGUgcGF0aG5hbWUgbWF0Y2hlcyBidXQgdGhlIHNlYXJjaCBwYXJhbXMgZG9uJ3QsXG4gICAgICAgICAgICBjb25zdCBpc0FsaWFzZWQgPSBleGlzdGluZ0VudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmIGV4aXN0aW5nRW50cnkudXJsLnNlYXJjaCAhPT0gdXJsLnNlYXJjaDtcbiAgICAgICAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGNvbnRhaW5zIHNlYXJjaCBwYXJhbXMsIGFuZCB3ZSdyZSBub3QgZG9pbmcgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSBjb3ZlcmVkIGJ5IHRoZSBjaGVjayBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZnVuY3Rpb24sIHdoaWNoIGl0ZXJhdGVzIG92ZXIgY2FjaGUgZW50cmllcyxcbiAgICAgICAgLy8gYnV0IGxldHMgdXMgYXJyaXZlIHRoZXJlIHF1aWNrZXIgaW4gdGhlIHBhcmFtLWZ1bGwgY2FzZS5cbiAgICAgICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGFsbG93QWxpYXNpbmcgJiYgdXJsLnNlYXJjaCAmJiBraW5kICE9PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMICYmIGVudHJ5V2l0aG91dFBhcmFtcyAmJiAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgIWVudHJ5V2l0aG91dFBhcmFtcy5rZXkuaW5jbHVkZXMoSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmVudHJ5V2l0aG91dFBhcmFtcyxcbiAgICAgICAgICAgICAgICBhbGlhc2VkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB3ZSBkaWRuJ3QgZmluZCBhIHNwZWNpZmljIGNhY2hlIGVudHJ5IHRoYXQgbWF0Y2hlZFxuICAgIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgICAvLyBXZSBhdHRlbXB0IGEgcGFydGlhbCBtYXRjaCBieSBjaGVja2luZyBpZiB0aGVyZSdzIGEgY2FjaGUgZW50cnkgd2l0aCB0aGUgc2FtZSBwYXRobmFtZS5cbiAgICAvLyBSZWdhcmRsZXNzIG9mIHdoYXQgd2UgZmluZCwgc2luY2UgaXQgZG9lc24ndCBjb3JyZXNwb25kIHdpdGggdGhlIHJlcXVlc3RlZCBVUkwsIHdlJ2xsIG1hcmsgaXQgXCJhbGlhc2VkXCIuXG4gICAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYga2luZCAhPT0gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTCAmJiBhbGxvd0FsaWFzaW5nKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKXtcbiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAgICAgICAvLyBTaW5jZSBpdCdzIHJld3JpdHRlbiwgaXQgY291bGQgcmVzcG9uZCB3aXRoIGEgY29tcGxldGVseSBkaWZmZXJlbnQgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWNoZUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkocGFyYW0pIHtcbiAgICBsZXQgeyB1cmwsIG5leHRVcmwsIHRyZWUsIHByZWZldGNoQ2FjaGUsIGtpbmQsIGFsbG93QWxpYXNpbmcgPSB0cnVlIH0gPSBwYXJhbTtcbiAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBnZXRFeGlzdGluZ0NhY2hlRW50cnkodXJsLCBraW5kLCBuZXh0VXJsLCBwcmVmZXRjaENhY2hlLCBhbGxvd0FsaWFzaW5nKTtcbiAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgIC8vIEdyYWIgdGhlIGxhdGVzdCBzdGF0dXMgb2YgdGhlIGNhY2hlIGVudHJ5IGFuZCB1cGRhdGUgaXRcbiAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YXR1cyA9IGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhleGlzdGluZ0NhY2hlRW50cnkpO1xuICAgICAgICAvLyB3aGVuIGBraW5kYCBpcyBwcm92aWRlZCwgYW4gZXhwbGljaXQgcHJlZmV0Y2ggd2FzIHJlcXVlc3RlZC5cbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICAgICAgY29uc3Qgc3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCA9IGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMICYmIGtpbmQgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEw7XG4gICAgICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPSBBcnJheS5pc0FycmF5KHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YSkgJiYgcHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhLnNvbWUoKGZsaWdodERhdGEpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIGZyb20gdGhlIHJvb3QgYW5kIHdlIHJldHVybmVkIFJTQyBkYXRhIChzZWVkRGF0YSksIHdlIGFscmVhZHkgaGFkIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsaWdodERhdGEuaXNSb290UmVuZGVyICYmIGZsaWdodERhdGEuc2VlZERhdGEgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBleHBsaWNpdCBwcmVmZXRjaCBraW5kLCB3ZSB3YW50IHRvIHNldCBhIHRlbXBvcmFyeSBraW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBhc3N1bWluZyB0aGUgc2FtZSBpbnRlbnQgYXMgdGhlIHByZXZpb3VzIGVudHJ5LCB0byBiZSBjb25zaXN0ZW50IHdpdGggaG93IHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsYXppbHkgY3JlYXRlIHByZWZldGNoIGVudHJpZXMgd2hlbiBpbnRlbnQgaXMgbGVmdCB1bnNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQgIT0gbnVsbCA/IGtpbmQgOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5URU1QT1JBUllcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAgICAgLy8gd2hlcmUgd2UgZGlkbid0IGhhdmUgdGhlIHByZWZldGNoIGludGVudC4gTm93IHRoYXQgd2UgaGF2ZSB0aGUgaW50ZW50IChpbiBga2luZGApLCB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZW50cnkgdG8gdGhlIG1vcmUgYWNjdXJhdGUga2luZC5cbiAgICAgICAgaWYgKGtpbmQgJiYgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPT09IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSkge1xuICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCB0aGUgZXhpc3RpbmcgZW50cnkgd2UgZm91bmQgaXMgc3RpbGwgdmFsaWQsIHNvIHdlIHJldHVybiBpdC5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeTtcbiAgICB9XG4gICAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgICAgICB0cmVlLFxuICAgICAgICB1cmwsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIGtpbmQ6IGtpbmQgfHwgX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuVEVNUE9SQVJZXG4gICAgfSk7XG59XG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqLyBmdW5jdGlvbiBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeShwYXJhbSkge1xuICAgIGxldCB7IHVybCwgbmV4dFVybCwgcHJlZmV0Y2hDYWNoZSwgZXhpc3RpbmdDYWNoZUtleSB9ID0gcGFyYW07XG4gICAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAgICAgLy8gbm8tb3AgLS0gdGhlcmUgd2Fzbid0IGFuIGVudHJ5IHRvIG1vdmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDYWNoZUtleSA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBleGlzdGluZ0NhY2hlRW50cnkua2luZCwgbmV4dFVybCk7XG4gICAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHtcbiAgICAgICAgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LFxuICAgICAgICBrZXk6IG5ld0NhY2hlS2V5XG4gICAgfSk7XG4gICAgcHJlZmV0Y2hDYWNoZS5kZWxldGUoZXhpc3RpbmdDYWNoZUtleSk7XG4gICAgcmV0dXJuIG5ld0NhY2hlS2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgbmV4dFVybCwgdHJlZSwgcHJlZmV0Y2hDYWNoZSwgdXJsLCBkYXRhLCBraW5kIH0gPSBwYXJhbTtcbiAgICAvLyBUaGUgaW5pdGlhbCBjYWNoZSBlbnRyeSB0ZWNobmljYWxseSBpbmNsdWRlcyBmdWxsIGRhdGEsIGJ1dCBpdCBpc24ndCBleHBsaWNpdGx5IHByZWZldGNoZWQgLS0gd2UganVzdCBzZWVkIHRoZVxuICAgIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAgIC8vIGlmIHRoZSBwcmVmZXRjaCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgdXNlIHRoZSBuZXh0VXJsIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5XG4gICAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGRhdGEuY291bGRCZUludGVyY2VwdGVkID8gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQsIG5leHRVcmwpIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpO1xuICAgIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgICAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAgICAgIGtpbmQsXG4gICAgICAgIHByZWZldGNoVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBzdGFsZVRpbWU6IC0xLFxuICAgICAgICBrZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgICAgIHN0YXR1czogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2gsXG4gICAgICAgIHVybFxuICAgIH07XG4gICAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSk7XG4gICAgcmV0dXJuIHByZWZldGNoRW50cnk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovIGZ1bmN0aW9uIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCBraW5kLCB0cmVlLCBuZXh0VXJsLCBwcmVmZXRjaENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpO1xuICAgIC8vIGluaXRpYXRlcyB0aGUgZmV0Y2ggcmVxdWVzdCBmb3IgdGhlIHByZWZldGNoIGFuZCBhdHRhY2hlcyBhIGxpc3RlbmVyXG4gICAgLy8gdG8gdGhlIHByb21pc2UgdG8gdXBkYXRlIHRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzIChpZiBuZWNlc3NhcnkpXG4gICAgY29uc3QgZGF0YSA9IF9wcmVmZXRjaHJlZHVjZXIucHJlZmV0Y2hRdWV1ZS5lbnF1ZXVlKCgpPT4oMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkodXJsLCB7XG4gICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICBwcmVmZXRjaEtpbmQ6IGtpbmRcbiAgICAgICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSk9PntcbiAgICAgICAgICAgIC8vIFRPRE86IGBmZXRjaFNlcnZlclJlc3BvbnNlYCBzaG91bGQgYmUgbW9yZSB0aWdobHkgY291cGxlZCB0byB0aGVzZSBwcmVmZXRjaCBjYWNoZSBvcGVyYXRpb25zXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBkcmlmdCBiZXR3ZWVuIHRoaXMgY2FjaGUga2V5IHByZWZpeGluZyBsb2dpY1xuICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGN1cnJlbnRseSBkaXJlY3RseSBpbmZsdWVuY2VkIGJ5IHRoZSBzZXJ2ZXIgcmVzcG9uc2UpXG4gICAgICAgICAgICBsZXQgbmV3Q2FjaGVLZXk7XG4gICAgICAgICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBwcmVmaXggdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXh0VXJsXG4gICAgICAgICAgICAgICAgbmV3Q2FjaGVLZXkgPSBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHByZWZldGNoIHdhcyBhIGNhY2hlIGhpdCwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHRvIHJlZmxlY3QgdGhhdCBpdCB3YXMgYSBmdWxsIHByZWZldGNoLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGtub3cgdGhhdCBhIHN0YXRpYyByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlIGZ1bGwgUlNDIHBheWxvYWQsIGFuZCBjYW4gYmUgdXBkYXRlZCB0byByZXNwZWN0IHRoZSBgc3RhdGljYFxuICAgICAgICAgICAgLy8gc3RhbGVUaW1lLlxuICAgICAgICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UucHJlcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldCgvLyBpZiB3ZSBwcmVmaXhlZCB0aGUgY2FjaGUga2V5IGR1ZSB0byByb3V0ZSBpbnRlcmNlcHRpb24sIHdlIHdhbnQgdG8gdXNlIHRoZSBuZXcga2V5LiBPdGhlcndpc2Ugd2UgdXNlIHRoZSBvcmlnaW5hbCBrZXlcbiAgICAgICAgICAgICAgICBuZXdDYWNoZUtleSAhPSBudWxsID8gbmV3Q2FjaGVLZXkgOiBwcmVmZXRjaENhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RhbGUgdGltZSB0aGF0IHdhcyBjb2xsZWN0ZWQgYnkgdGhlIHNlcnZlciBkdXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRpYyBnZW5lcmF0aW9uLiBVc2UgdGhpcyBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBzdGFsZSB0aW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LnN0YWxlVGltZSA9IHByZWZldGNoUmVzcG9uc2Uuc3RhbGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZWZldGNoUmVzcG9uc2U7XG4gICAgICAgIH0pKTtcbiAgICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgICAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAga2luZCxcbiAgICAgICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBsYXN0VXNlZFRpbWU6IG51bGwsXG4gICAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgc3RhdHVzOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCxcbiAgICAgICAgdXJsXG4gICAgfTtcbiAgICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KTtcbiAgICByZXR1cm4gcHJlZmV0Y2hFbnRyeTtcbn1cbmZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShwcmVmZXRjaENhY2hlKSB7XG4gICAgZm9yIChjb25zdCBbaHJlZiwgcHJlZmV0Y2hDYWNoZUVudHJ5XSBvZiBwcmVmZXRjaENhY2hlKXtcbiAgICAgICAgaWYgKGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkKSB7XG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlLmRlbGV0ZShocmVmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDA7XG5jb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID0gTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMDtcbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwYXJhbSkge1xuICAgIGxldCB7IGtpbmQsIHByZWZldGNoVGltZSwgbGFzdFVzZWRUaW1lLCBzdGFsZVRpbWUgfSA9IHBhcmFtO1xuICAgIGlmIChzdGFsZVRpbWUgIT09IC0xKSB7XG4gICAgICAgIC8vIGBzdGFsZVRpbWVgIGlzIHRoZSB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgICAgICAvLyBXaGVuIHRoaXMgaXMgYXZhaWxhYmxlLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9mIHRoZSBoZXVyaXN0aWNzXG4gICAgICAgIC8vIHRoYXQgZm9sbG93LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUT0RPOiBXaGVuIFBQUiBpcyBlbmFibGVkLCB0aGUgc2VydmVyIHdpbGwgKmFsd2F5cyogcmV0dXJuIGEgc3RhbGUgdGltZVxuICAgICAgICAvLyB3aGVuIHByZWZldGNoaW5nLiBXZSBzaG91bGQgbmV2ZXIgdXNlIGEgcHJlZmV0Y2ggZW50cnkgdGhhdCBoYXNuJ3QgeWV0XG4gICAgICAgIC8vIHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBTbyB0aGUgb25seSB0d28gY2FzZXMgc2hvdWxkIGJlIDEpIHdlIHVzZVxuICAgICAgICAvLyB0aGUgc2VydmVyLWdlbmVyYXRlZCBzdGFsZSB0aW1lIDIpIHRoZSB1bnJlc29sdmVkIGVudHJ5IGlzIGRpc2NhcmRlZC5cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBzdGFsZVRpbWUgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlO1xuICAgIH1cbiAgICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSAhPSBudWxsID8gbGFzdFVzZWRUaW1lIDogcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICAgIHJldHVybiBsYXN0VXNlZFRpbWUgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZSA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoO1xuICAgIH1cbiAgICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIFwibGF6eSBmZXRjaFwiIGZvciB0aGUgZnVsbCBkYXRhLlxuICAgIGlmIChraW5kID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgICAgICAgcmV0dXJuIF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBcImZ1bGxcIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAgIGlmIChraW5kID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgICAgICAgcmV0dXJuIF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnJldXNhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmZXRjaC1jYWNoZS11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJTVEFUSUNfU1RBTEVUSU1FX01TIiwiY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsInJlcXVpcmUiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwiX3ByZWZldGNocmVkdWNlciIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJwYXJhbSIsInRyZWUiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJzdGF0dXMiLCJnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMiLCJzd2l0Y2hlZFRvRnVsbFByZWZldGNoIiwiZGF0YSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaXNGdWxsUHJlZmV0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJmbGlnaHREYXRhIiwic29tZSIsImlzUm9vdFJlbmRlciIsInNlZWREYXRhIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsInByZWZldGNoQ2FjaGVLZXkiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJzdGFsZVRpbWUiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImZsaWdodFJvdXRlclN0YXRlIiwicHJlZmV0Y2hLaW5kIiwicHJlcmVuZGVyZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiTnVtYmVyIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FIiwic3RhbGUiLCJyZXVzYWJsZSIsIkFVVE8iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    if (parallelRoutes.children) {\n        const [segment, childParallelRoutes] = parallelRoutes.children;\n        const childSegmentMap = cache.parallelRoutes.get('children');\n        if (childSegmentMap) {\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n            const cacheNode = childSegmentMap.get(cacheKey);\n            if (cacheNode) {\n                const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n                if (item) return item;\n            }\n        }\n    }\n    // if we didn't find metadata in the page slot, check the other parallel routes\n    for(const key in parallelRoutes){\n        if (key === 'children') continue; // already checked above\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx3QkFBd0JDLG1CQUFPQSxDQUFDLDRJQUE0QjtBQUNsRSxTQUFTRixnQkFBZ0JHLEtBQUssRUFBRUMsY0FBYztJQUMxQyxPQUFPQyxvQkFBb0JGLE9BQU9DLGdCQUFnQjtBQUN0RDtBQUNBLFNBQVNDLG9CQUFvQkYsS0FBSyxFQUFFQyxjQUFjLEVBQUVFLFNBQVM7SUFDekQsTUFBTUMsYUFBYWIsT0FBT2MsSUFBSSxDQUFDSixnQkFBZ0JLLE1BQU0sS0FBSztJQUMxRCxJQUFJRixZQUFZO1FBQ1osMEVBQTBFO1FBQzFFLE9BQU87WUFDSEo7WUFDQUc7U0FDSDtJQUNMO0lBQ0EsdURBQXVEO0lBQ3ZELCtFQUErRTtJQUMvRSxJQUFJRixlQUFlTSxRQUFRLEVBQUU7UUFDekIsTUFBTSxDQUFDQyxTQUFTQyxvQkFBb0IsR0FBR1IsZUFBZU0sUUFBUTtRQUM5RCxNQUFNRyxrQkFBa0JWLE1BQU1DLGNBQWMsQ0FBQ0wsR0FBRyxDQUFDO1FBQ2pELElBQUljLGlCQUFpQjtZQUNqQixNQUFNQyxXQUFXLENBQUMsR0FBR2Isc0JBQXNCYyxvQkFBb0IsRUFBRUo7WUFDakUsTUFBTUssWUFBWUgsZ0JBQWdCZCxHQUFHLENBQUNlO1lBQ3RDLElBQUlFLFdBQVc7Z0JBQ1gsTUFBTUMsT0FBT1osb0JBQW9CVyxXQUFXSixxQkFBcUJOLFlBQVksTUFBTVE7Z0JBQ25GLElBQUlHLE1BQU0sT0FBT0E7WUFDckI7UUFDSjtJQUNKO0lBQ0EsK0VBQStFO0lBQy9FLElBQUksTUFBTUMsT0FBT2QsZUFBZTtRQUM1QixJQUFJYyxRQUFRLFlBQVksVUFBVSx3QkFBd0I7UUFDMUQsTUFBTSxDQUFDUCxTQUFTQyxvQkFBb0IsR0FBR1IsY0FBYyxDQUFDYyxJQUFJO1FBQzFELE1BQU1MLGtCQUFrQlYsTUFBTUMsY0FBYyxDQUFDTCxHQUFHLENBQUNtQjtRQUNqRCxJQUFJLENBQUNMLGlCQUFpQjtZQUNsQjtRQUNKO1FBQ0EsTUFBTUMsV0FBVyxDQUFDLEdBQUdiLHNCQUFzQmMsb0JBQW9CLEVBQUVKO1FBQ2pFLE1BQU1LLFlBQVlILGdCQUFnQmQsR0FBRyxDQUFDZTtRQUN0QyxJQUFJLENBQUNFLFdBQVc7WUFDWjtRQUNKO1FBQ0EsTUFBTUMsT0FBT1osb0JBQW9CVyxXQUFXSixxQkFBcUJOLFlBQVksTUFBTVE7UUFDbkYsSUFBSUcsTUFBTTtZQUNOLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPckIsUUFBUXVCLE9BQU8sS0FBSyxjQUFlLE9BQU92QixRQUFRdUIsT0FBTyxLQUFLLFlBQVl2QixRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdkIsUUFBUXVCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksxQixPQUFPQyxjQUFjLENBQUNDLFFBQVF1QixPQUFPLEVBQUUsY0FBYztRQUFFdEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPMkIsTUFBTSxDQUFDekIsUUFBUXVCLE9BQU8sRUFBRXZCO0lBQy9CMEIsT0FBTzFCLE9BQU8sR0FBR0EsUUFBUXVCLE9BQU87QUFDbEMsRUFFQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kSGVhZEluQ2FjaGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsICcnKTtcbn1cbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZUltcGwoY2FjaGUsIHBhcmFsbGVsUm91dGVzLCBrZXlQcmVmaXgpIHtcbiAgICBjb25zdCBpc0xhc3RJdGVtID0gT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoaXNMYXN0SXRlbSkge1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSBlbnRpcmUgQ2FjaGUgTm9kZSBvZiB0aGUgc2VnbWVudCB3aG9zZSBoZWFkIHdlIHdpbGwgcmVuZGVyLlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBrZXlQcmVmaXhcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gRmlyc3QgdHJ5IHRoZSAnY2hpbGRyZW4nIHBhcmFsbGVsIHJvdXRlIGlmIGl0IGV4aXN0c1xuICAgIC8vIHdoZW4gc3RhcnRpbmcgZnJvbSB0aGUgXCJyb290XCIsIHRoaXMgY29ycmVzcG9uZHMgd2l0aCB0aGUgbWFpbiBwYWdlIGNvbXBvbmVudFxuICAgIGlmIChwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBbc2VnbWVudCwgY2hpbGRQYXJhbGxlbFJvdXRlc10gPSBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgICBpZiAoY2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHNlZ21lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZUltcGwoY2FjaGVOb2RlLCBjaGlsZFBhcmFsbGVsUm91dGVzLCBrZXlQcmVmaXggKyAnLycgKyBjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIG1ldGFkYXRhIGluIHRoZSBwYWdlIHNsb3QsIGNoZWNrIHRoZSBvdGhlciBwYXJhbGxlbCByb3V0ZXNcbiAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykgY29udGludWU7IC8vIGFscmVhZHkgY2hlY2tlZCBhYm92ZVxuICAgICAgICBjb25zdCBbc2VnbWVudCwgY2hpbGRQYXJhbGxlbFJvdXRlc10gPSBwYXJhbGxlbFJvdXRlc1trZXldO1xuICAgICAgICBjb25zdCBjaGlsZFNlZ21lbnRNYXAgPSBjYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkoc2VnbWVudCk7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZUltcGwoY2FjaGVOb2RlLCBjaGlsZFBhcmFsbGVsUm91dGVzLCBrZXlQcmVmaXggKyAnLycgKyBjYWNoZUtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC1oZWFkLWluLWNhY2hlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJmaW5kSGVhZEluQ2FjaGUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJyZXF1aXJlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImZpbmRIZWFkSW5DYWNoZUltcGwiLCJrZXlQcmVmaXgiLCJpc0xhc3RJdGVtIiwia2V5cyIsImxlbmd0aCIsImNoaWxkcmVuIiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiY2FjaGVOb2RlIiwiaXRlbSIsImtleSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js ***!
  \***********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLGdCQUFnQkMsT0FBTztJQUM1QixPQUFPQyxNQUFNQyxPQUFPLENBQUNGLFdBQVdBLE9BQU8sQ0FBQyxFQUFFLEdBQUdBO0FBQ2pEO0FBRUEsSUFBSSxDQUFDLE9BQU9MLFFBQVFRLE9BQU8sS0FBSyxjQUFlLE9BQU9SLFFBQVFRLE9BQU8sS0FBSyxZQUFZUixRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9SLFFBQVFRLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktYLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTztJQUFLO0lBQ25FSCxPQUFPWSxNQUFNLENBQUNWLFFBQVFRLE9BQU8sRUFBRVI7SUFDL0JXLE9BQU9YLE9BQU8sR0FBR0EsUUFBUVEsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2dldC1zZWdtZW50LXZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U2VnbWVudFZhbHVlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRTZWdtZW50VmFsdWU7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBnZXRTZWdtZW50VmFsdWUoc2VnbWVudCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zZWdtZW50LXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXRTZWdtZW50VmFsdWUiLCJzZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js ***!
  \********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../shared/lib/router/utils/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interception-routes.js\");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHFFQUFvRTtJQUNoRUksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHNCQUFzQkMsbUJBQU9BLENBQUMsNEpBQXlEO0FBQzdGLFNBQVNGLGtDQUFrQ0csS0FBSztJQUM1QyxJQUFJLENBQUNDLFNBQVNDLGVBQWUsR0FBR0Y7SUFDaEMsd0dBQXdHO0lBQ3hHLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0gsWUFBYUEsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRQSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUcsR0FBSTtRQUN4RSxPQUFPO0lBQ1g7SUFDQSxvRUFBb0U7SUFDcEUsSUFBSSxPQUFPQSxZQUFZLFlBQVksQ0FBQyxHQUFHSCxvQkFBb0JPLDBCQUEwQixFQUFFSixVQUFVO1FBQzdGLE9BQU87SUFDWDtJQUNBLCtDQUErQztJQUMvQyxJQUFJQyxnQkFBZ0I7UUFDaEIsSUFBSSxNQUFNSSxPQUFPSixlQUFlO1lBQzVCLElBQUlMLGtDQUFrQ0ssY0FBYyxDQUFDSSxJQUFJLEdBQUc7Z0JBQ3hELE9BQU87WUFDWDtRQUNKO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0IsTUFBTSxDQUFDaEIsUUFBUWMsT0FBTyxFQUFFZDtJQUMvQmlCLE9BQU9qQixPQUFPLEdBQUdBLFFBQVFjLE9BQU87QUFDbEMsRUFFQSxrRUFBa0UiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyY2VwdGlvbnJvdXRlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuZnVuY3Rpb24gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHBhcmFtKSB7XG4gICAgbGV0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBwYXJhbTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgZHluYW1pYyBzZWdtZW50LCBpdCdzIG1hcmtlZCBhcyBhbiBpbnRlcmNlcHRpb24gcm91dGUgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBgaWAgc3VmZml4LlxuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpICYmIChzZWdtZW50WzJdID09PSAnZGknIHx8IHNlZ21lbnRbMl0gPT09ICdjaScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJZiBzZWdtZW50IGlzIG5vdCBhbiBhcnJheSwgYXBwbHkgdGhlIGV4aXN0aW5nIHN0cmluZy1iYXNlZCBjaGVja1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycgJiYgKDAsIF9pbnRlcmNlcHRpb25yb3V0ZXMuaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgpKHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggcGFyYWxsZWxSb3V0ZXMgaWYgdGhleSBleGlzdFxuICAgIGlmIChwYXJhbGxlbFJvdXRlcykge1xuICAgICAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUocGFyYWxsZWxSb3V0ZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwicmVxdWlyZSIsInBhcmFtIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJrZXkiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgscURBQW9EO0lBQ2hESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3SUFBMEI7QUFDL0QsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQyxzSUFBeUI7QUFDNUQsTUFBTUUsK0JBQStCRixtQkFBT0EsQ0FBQyw4SkFBcUM7QUFDbEYsTUFBTUcsK0JBQStCSCxtQkFBT0EsQ0FBQyw4SkFBcUM7QUFDbEYsTUFBTUksbUJBQW1CSixtQkFBT0EsQ0FBQyxzSUFBb0I7QUFDckQsTUFBTUssaUJBQWlCTCxtQkFBT0EsQ0FBQywwSEFBbUI7QUFDbEQsTUFBTU0sbUJBQW1CTixtQkFBT0EsQ0FBQyxnSUFBc0I7QUFDdkQsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsc0dBQWtCO0FBQzdDLE1BQU1RLHlCQUF5QlIsbUJBQU9BLENBQUMsNElBQTRCO0FBQ25FLE1BQU1TLHFDQUFxQ1QsbUJBQU9BLENBQUMsa0xBQTBDO0FBQzdGLHdGQUF3RjtBQUN4RixTQUFTVSxzQkFBc0JDLEtBQUssRUFBRUMsTUFBTTtJQUN4QyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUNuQixNQUFNRSxVQUFVLENBQUM7SUFDakIsTUFBTUMsT0FBT0osTUFBTUssWUFBWTtJQUMvQkYsUUFBUUcsMEJBQTBCLEdBQUc7SUFDckMsTUFBTUMsUUFBUSxDQUFDLEdBQUdYLFdBQVdZLG9CQUFvQjtJQUNqRCxzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQixDQUFDLEdBQUdYLG1D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QU87SUFBSztJQUNuRUgsT0FBT3FFLE1BQU0sQ0FBQ25FLFFBQVFpRSxPQUFPLEVBQUVqRTtJQUMvQm9FLE9BQU9wRSxPQUFPLEdBQUdBLFFBQVFpRSxPQUFPO0FBQ2xDLEVBRUEsK0NBQStDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhtclJlZnJlc2hSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBobXJSZWZyZXNoUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4uL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG5jb25zdCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuY29uc3QgX25hdmlnYXRlcmVkdWNlciA9IHJlcXVpcmUoXCIuL25hdmlnYXRlLXJlZHVjZXJcIik7XG5jb25zdCBfaGFuZGxlbXV0YWJsZSA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtbXV0YWJsZVwiKTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi4vYXBwbHktZmxpZ2h0LWRhdGFcIik7XG5jb25zdCBfYXBwcm91dGVyID0gcmVxdWlyZShcIi4uLy4uL2FwcC1yb3V0ZXJcIik7XG5jb25zdCBfaGFuZGxlc2VnbWVudG1pc21hdGNoID0gcmVxdWlyZShcIi4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoXCIpO1xuY29uc3QgX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSA9IHJlcXVpcmUoXCIuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlXCIpO1xuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG11dGFibGUgPSB7fTtcbiAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShzdGF0ZS50cmVlKTtcbiAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgIGNhY2hlLmxhenlEYXRhID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwge1xuICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW1xuICAgICAgICAgICAgc3RhdGUudHJlZVswXSxcbiAgICAgICAgICAgIHN0YXRlLnRyZWVbMV0sXG4gICAgICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICAgICAgJ3JlZmV0Y2gnXG4gICAgICAgIF0sXG4gICAgICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsXG4gICAgICAgIGlzSG1yUmVmcmVzaDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9ID0gcGFyYW07XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgY2FjaGUubGF6eURhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgY2FjaGUubGF6eURhdGEgPSBudWxsO1xuICAgICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGU7XG4gICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YTtcbiAgICAgICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JFRlJFU0ggRkFJTEVEJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICBdLCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCBzdGF0ZS5jYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVzZWdtZW50bWlzbWF0Y2guaGFuZGxlU2VnbWVudE1pc21hdGNoKShzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0LmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBwbGllZCA9ICgwLCBfYXBwbHlmbGlnaHRkYXRhLmFwcGx5RmxpZ2h0RGF0YSkoY3VycmVudENhY2hlLCBjYWNoZSwgbm9ybWFsaXplZEZsaWdodERhdGEpO1xuICAgICAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZjtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9LCAoKT0+c3RhdGUpO1xufVxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKHN0YXRlLCBfYWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gaG1yUmVmcmVzaFJlZHVjZXJOb29wIDogaG1yUmVmcmVzaFJlZHVjZXJJbXBsO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1obXItcmVmcmVzaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJobXJSZWZyZXNoUmVkdWNlciIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX25hdmlnYXRlcmVkdWNlciIsIl9oYW5kbGVtdXRhYmxlIiwiX2FwcGx5ZmxpZ2h0ZGF0YSIsIl9hcHByb3V0ZXIiLCJfaGFuZGxlc2VnbWVudG1pc21hdGNoIiwiX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSIsImhtclJlZnJlc2hSZWR1Y2VySW1wbCIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsInRyZWUiLCJsYXp5RGF0YSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJpc0htclJlZnJlc2giLCJ0aGVuIiwicGFyYW0iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\");\nconst _aliasedprefetchnavigations = __webpack_require__(/*! ../aliased-prefetch-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _segmentcache.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _segmentcache.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    if (false) {}\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        prefetchCache: state.prefetchCache,\n        allowAliasing\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        if (prefetchValues.aliased) {\n            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(state, flightData, url, mutable);\n            // We didn't return new router state because we didn't apply the aliased entry for some reason.\n            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n            // will create an on-demand prefetch entry.\n            if (result === false) {\n                return navigateReducer(state, {\n                    ...action,\n                    allowAliasing: false\n                });\n            }\n            return result;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];\n        // If only the hash has changed, the server hasn't sent us any new data. We can just update\n        // the mutable properties responsible for URL and scroll handling and return early.\n        if (onlyHashChange) {\n            mutable.onlyHashChange = true;\n            mutable.canonicalUrl = updatedCanonicalUrl;\n            mutable.shouldScroll = shouldScroll;\n            mutable.hashFragment = hash;\n            mutable.scrollableSegments = [];\n            return (0, _handlemutable.handleMutable)(state, mutable);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const normalizedFlightData of flightData){\n            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;\n            let treePatch = normalizedFlightData.tree;\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                '',\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if (// will send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via startPPRNavigation. The current structure is just\n                // an incremental step.\n                seedData && isRootRender && postponed) {\n                    const task = (0, _pprnavigations.startPPRNavigation)(currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);\n                    if (task !== null) {\n                        if (task.route === null) {\n                            // Detected a change to the root layout. Perform an full-\n                            // page navigation.\n                            return handleExternalUrl(state, mutable, href, pendingPush);\n                        }\n                        // Use the tree computed by startPPRNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        if (newCache !== null) {\n                            // We've created a new Cache Node tree that contains a prefetched\n                            // version of the next page. This can be rendered instantly.\n                            mutable.cache = newCache;\n                        }\n                        const dynamicRequestTree = task.dynamicRequestTree;\n                        if (dynamicRequestTree !== null) {\n                            // The prefetched tree has dynamic holes in it. We initiate a\n                            // dynamic request to fill them in.\n                            //\n                            // Do not block on the result. We'll immediately render the Cache\n                            // Node tree and suspend on the dynamic parts. When the request\n                            // comes in, we'll fill in missing data and ping React to\n                            // re-render. Unlike the lazy fetching model in the non-PPR\n                            // implementation, this is modeled as a single React update +\n                            // streaming, rather than multiple top-level updates. (However,\n                            // even in the new model, we'll still need to sometimes update the\n                            // root multiple times per navigation, like if the server sends us\n                            // a different response than we expected. For now, we revert back\n                            // to the lazy fetching mechanism in that case.)\n                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                                flightRouterState: dynamicRequestTree,\n                                nextUrl: state.nextUrl\n                            });\n                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);\n                        // We store the dynamic request on the `lazyData` property of the CacheNode\n                        // because we're not going to await the dynamic request here. Since we're not blocking\n                        // on the dynamic request, `layout-router` will\n                        // task.node.lazyData = dynamicRequest\n                        } else {\n                        // The prefetched tree does not contain dynamic holes — it's\n                        // fully static. We can skip the dynamic request.\n                        }\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = treePatch;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                        return handleExternalUrl(state, mutable, href, pendingPush);\n                    }\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                    for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                        const scrollableSegmentPath = [\n                            ...flightSegmentPath,\n                            ...subSegment\n                        ];\n                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                            scrollableSegments.push(scrollableSegmentPath);\n                        }\n                    }\n                }\n                currentTree = newTree;\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = updatedCanonicalUrl;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsbUJBQW1CO1FBQ2YsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyx1QkFBdUJDLG1CQUFPQSxDQUFDLHdJQUEwQjtBQUMvRCxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM1RCxNQUFNRSx5Q0FBeUNGLG1CQUFPQSxDQUFDLGdMQUE4QztBQUNyRyxNQUFNRywrQkFBK0JILG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNSSxzQkFBc0JKLG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM3RCxNQUFNSywrQkFBK0JMLG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNTSxzQkFBc0JOLG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM3RCxNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDLDBIQUFtQjtBQUNsRCxNQUFNUSxtQkFBbUJSLG1CQUFPQSxDQUFDLGdJQUFzQjtBQUN2RCxNQUFNUyxtQkFBbUJULG1CQUFPQSxDQUFDLHNJQUFvQjtBQUNyRCxNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQyxzR0FBa0I7QUFDN0MsTUFBTVcsV0FBV1gsbUJBQU9BLENBQUMsMEdBQWdDO0FBQ3pELE1B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LDhFQUE4RTt3QkFDOUU5QixlQUFlOEI7b0JBQ25CO29CQUNBLEtBQUssTUFBTXVFLGNBQWNuSCwwQkFBMEJnQixXQUFXO3dCQUMxRCxNQUFNb0csd0JBQXdCOytCQUN2QnJHOytCQUNBb0c7eUJBQ047d0JBQ0Qsa0ZBQWtGO3dCQUNsRixJQUFJQyxxQkFBcUIsQ0FBQ0Esc0JBQXNCOUcsTUFBTSxHQUFHLEVBQUUsS0FBS3JCLFNBQVNvSSxtQkFBbUIsRUFBRTs0QkFDMUZ4SCxtQkFBbUJjLElBQUksQ0FBQ3lHO3dCQUM1QjtvQkFDSjtnQkFDSjtnQkFDQTlCLGNBQWNRO1lBQ2xCO1FBQ0o7UUFDQXRHLFFBQVFzRCxXQUFXLEdBQUd3QztRQUN0QjlGLFFBQVFJLFlBQVksR0FBR3dGO1FBQ3ZCNUYsUUFBUUssa0JBQWtCLEdBQUdBO1FBQzdCTCxRQUFRa0QsWUFBWSxHQUFHRjtRQUN2QmhELFFBQVFpRCxZQUFZLEdBQUdBO1FBQ3ZCLE9BQU8sQ0FBQyxHQUFHNUQsZUFBZWtCLGFBQWEsRUFBRVIsT0FBT0M7SUFDcEQsR0FBRyxJQUFJRDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU83QixRQUFRNEosT0FBTyxLQUFLLGNBQWUsT0FBTzVKLFFBQVE0SixPQUFPLEtBQUssWUFBWTVKLFFBQVE0SixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU81SixRQUFRNEosT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySy9KLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRKLE9BQU8sRUFBRSxjQUFjO1FBQUUzSixPQUFPO0lBQUs7SUFDbkVILE9BQU9nSyxNQUFNLENBQUM5SixRQUFRNEosT0FBTyxFQUFFNUo7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUTRKLE9BQU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaGFuZGxlRXh0ZXJuYWxVcmw6IG51bGwsXG4gICAgbmF2aWdhdGVSZWR1Y2VyOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGhhbmRsZUV4dGVybmFsVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsO1xuICAgIH0sXG4gICAgbmF2aWdhdGVSZWR1Y2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRlUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4uL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9pbnZhbGlkYXRlY2FjaGViZWxvd2ZsaWdodHNlZ21lbnRwYXRoID0gcmVxdWlyZShcIi4uL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoXCIpO1xuY29uc3QgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbmNvbnN0IF9zaG91bGRoYXJkbmF2aWdhdGUgPSByZXF1aXJlKFwiLi4vc2hvdWxkLWhhcmQtbmF2aWdhdGVcIik7XG5jb25zdCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuLi9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9wcmVmZXRjaHJlZHVjZXIgPSByZXF1aXJlKFwiLi9wcmVmZXRjaC1yZWR1Y2VyXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuY29uc3QgX3Bwcm5hdmlnYXRpb25zID0gcmVxdWlyZShcIi4uL3Bwci1uYXZpZ2F0aW9uc1wiKTtcbmNvbnN0IF9wcmVmZXRjaGNhY2hldXRpbHMgPSByZXF1aXJlKFwiLi4vcHJlZmV0Y2gtY2FjaGUtdXRpbHNcIik7XG5jb25zdCBfY2xlYXJjYWNoZW5vZGVkYXRhZm9yc2VnbWVudHBhdGggPSByZXF1aXJlKFwiLi4vY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGhcIik7XG5jb25zdCBfYWxpYXNlZHByZWZldGNobmF2aWdhdGlvbnMgPSByZXF1aXJlKFwiLi4vYWxpYXNlZC1wcmVmZXRjaC1uYXZpZ2F0aW9uc1wiKTtcbmNvbnN0IF9zZWdtZW50Y2FjaGUgPSByZXF1aXJlKFwiLi4vLi4vc2VnbWVudC1jYWNoZVwiKTtcbmZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwsIHBlbmRpbmdQdXNoKSB7XG4gICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHVybDtcbiAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gcGVuZGluZ1B1c2g7XG4gICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKGZsaWdodFJvdXRlclBhdGNoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyUGF0Y2g7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBzZWdtZW50XG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHBhcmFsbGVsUm91dGVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFsbGVsUm91dGVzKSl7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRTZWdtZW50IG9mIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2gocGFyYWxsZWxSb3V0ZSkpe1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgaXMgZW1wdHksIGl0IG1lYW5zIHdlIGFyZSBhdCB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkU2VnbWVudFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRTZWdtZW50XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xufVxuZnVuY3Rpb24gdHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyhuZXdDYWNoZSwgY3VycmVudENhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCwgdHJlZVBhdGNoKSB7XG4gICAgbGV0IGFwcGxpZWRQYXRjaCA9IGZhbHNlO1xuICAgIG5ld0NhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2M7XG4gICAgbmV3Q2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2M7XG4gICAgbmV3Q2FjaGUubG9hZGluZyA9IGN1cnJlbnRDYWNoZS5sb2FkaW5nO1xuICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChjdXJyZW50Q2FjaGUucGFyYWxsZWxSb3V0ZXMpO1xuICAgIGNvbnN0IHNlZ21lbnRQYXRoc1RvRmlsbCA9IGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2godHJlZVBhdGNoKS5tYXAoKHNlZ21lbnQpPT5bXG4gICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgIC4uLnNlZ21lbnRcbiAgICAgICAgXSk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50UGF0aHMgb2Ygc2VnbWVudFBhdGhzVG9GaWxsKXtcbiAgICAgICAgKDAsIF9jbGVhcmNhY2hlbm9kZWRhdGFmb3JzZWdtZW50cGF0aC5jbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCkobmV3Q2FjaGUsIGN1cnJlbnRDYWNoZSwgc2VnbWVudFBhdGhzKTtcbiAgICAgICAgYXBwbGllZFBhdGNoID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGxpZWRQYXRjaDtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIHJlc3VsdCkge1xuICAgIHN3aXRjaChyZXN1bHQudGFnKXtcbiAgICAgICAgY2FzZSBfc2VnbWVudGNhY2hlLk5hdmlnYXRpb25SZXN1bHRUYWcuTVBBOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VXJsID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBuZXdVcmwsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfc2VnbWVudGNhY2hlLk5hdmlnYXRpb25SZXN1bHRUYWcuTm9PcDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIG5vIGNoYW5nZSB0byB0aGUgY3VycmVudCBwYWdlLiBIb3dldmVyLCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBVUkwgY2hhbmdlZCwgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhhdC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDYW5vbmljYWxVcmwgPSByZXN1bHQuZGF0YS5jYW5vbmljYWxVcmw7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBuZXdDYW5vbmljYWxVcmw7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBjaGFuZ2VkIHdhcyB0aGUgaGFzaCBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICBjb25zdCBvbGRVcmwgPSBuZXcgVVJMKHN0YXRlLmNhbm9uaWNhbFVybCwgdXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmx5SGFzaENoYW5nZSA9IC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcGFyZSB0aGUgb3JpZ2lucywgYmVjYXVzZSBjbGllbnQtZHJpdmVuXG4gICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbnMgYXJlIGFsd2F5cyBzYW1lLW9yaWdpbi5cbiAgICAgICAgICAgICAgICB1cmwucGF0aG5hbWUgPT09IG9sZFVybC5wYXRobmFtZSAmJiB1cmwuc2VhcmNoID09PSBvbGRVcmwuc2VhcmNoICYmIHVybC5oYXNoICE9PSBvbGRVcmwuaGFzaDtcbiAgICAgICAgICAgICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgdXBkYXRlZCBwYXJ0IG9mIHRoZSBVUkwgaXMgdGhlIGhhc2guXG4gICAgICAgICAgICAgICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHJlc3VsdC5kYXRhLnNob3VsZFNjcm9sbDtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSB1cmwuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGFuIGVtcHR5IGFycmF5IHRyaWdnZXJzIGEgc2Nyb2xsIGZvciBhbGwgbmV3IGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIHNlZ21lbnRzLiBTZWUgYFNjcm9sbEFuZEZvY3VzSGFuZGxlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3NlZ21lbnRjYWNoZS5OYXZpZ2F0aW9uUmVzdWx0VGFnLlN1Y2Nlc3M6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gUmVjZWl2ZWQgYSBuZXcgcmVzdWx0LlxuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSByZXN1bHQuZGF0YS5jYWNoZU5vZGU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IHJlc3VsdC5kYXRhLmZsaWdodFJvdXRlclN0YXRlO1xuICAgICAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gcmVzdWx0LmRhdGEuY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gcmVzdWx0LmRhdGEuc2Nyb2xsYWJsZVNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gcmVzdWx0LmRhdGEuc2hvdWxkU2Nyb2xsO1xuICAgICAgICAgICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gcmVzdWx0LmRhdGEuaGFzaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfc2VnbWVudGNhY2hlLk5hdmlnYXRpb25SZXN1bHRUYWcuQXN5bmM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhLnRoZW4oKGFzeW5jUmVzdWx0KT0+aGFuZGxlTmF2aWdhdGlvblJlc3VsdCh1cmwsIHN0YXRlLCBtdXRhYmxlLCBwZW5kaW5nUHVzaCwgYXN5bmNSZXN1bHQpLCAvLyBJZiB0aGUgbmF2aWdhdGlvbiBmYWlsZWQsIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIG1hdGNoZXMgdGhlIGN1cnJlbnQgYmVoYXZpb3IgYnV0IHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgLy8gYmV0dGVyIGhlcmUgaWYgdGhlIG5ldHdvcmsgZmFpbHMuXG4gICAgICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwsIGFsbG93QWxpYXNpbmcgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBtdXRhYmxlID0ge307XG4gICAgY29uc3QgeyBoYXNoIH0gPSB1cmw7XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09ICdwdXNoJztcbiAgICAvLyB3ZSB3YW50IHRvIHBydW5lIHRoZSBwcmVmZXRjaCBjYWNoZSBvbiBldmVyeSBuYXZpZ2F0aW9uIHRvIGF2b2lkIGl0IGdyb3dpbmcgdG9vIGxhcmdlXG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMucHJ1bmVQcmVmZXRjaENhY2hlKShzdGF0ZS5wcmVmZXRjaENhY2hlKTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgIGlmIChpc0V4dGVybmFsVXJsKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgdXJsLnRvU3RyaW5nKCksIHBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIGA8bWV0YSBodHRwLWVxdWl2PVwicmVmcmVzaFwiPmAgdGFnIGlzIHByZXNlbnQsXG4gICAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0LXBhZ2UtcmVkaXJlY3QnKSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAvLyAoVmVyeSBFYXJseSBFeHBlcmltZW50YWwgRmVhdHVyZSkgU2VnbWVudCBDYWNoZVxuICAgICAgICAvL1xuICAgICAgICAvLyBCeXBhc3MgdGhlIG5vcm1hbCBwcmVmZXRjaCBjYWNoZSBhbmQgdXNlIHRoZSBuZXcgcGVyLXNlZ21lbnQgY2FjaGVcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gaW5zdGVhZC4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBpZiBQUFIgaXMgZW5hYmxlZCwgdG9vLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUZW1wb3JhcnkgZ2x1ZSBjb2RlIGJldHdlZW4gdGhlIHJvdXRlciByZWR1Y2VyIGFuZCB0aGUgbmV3IG5hdmlnYXRpb25cbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uIEV2ZW50dWFsbHkgd2UnbGwgcmV3cml0ZSB0aGUgcm91dGVyIHJlZHVjZXIgdG8gYVxuICAgICAgICAvLyBzdGF0ZSBtYWNoaW5lLlxuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3NlZ21lbnRjYWNoZS5uYXZpZ2F0ZSkodXJsLCBzdGF0ZS5jYWNoZSwgc3RhdGUudHJlZSwgc3RhdGUubmV4dFVybCwgc2hvdWxkU2Nyb2xsKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIHJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoVmFsdWVzID0gKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkpKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICB0cmVlOiBzdGF0ZS50cmVlLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICBhbGxvd0FsaWFzaW5nXG4gICAgfSk7XG4gICAgY29uc3QgeyB0cmVlQXRUaW1lT2ZQcmVmZXRjaCwgZGF0YSB9ID0gcHJlZmV0Y2hWYWx1ZXM7XG4gICAgX3ByZWZldGNocmVkdWNlci5wcmVmZXRjaFF1ZXVlLmJ1bXAoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEudGhlbigocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUsIHBvc3Rwb25lZCB9ID0gcGFyYW07XG4gICAgICAgIGxldCBpc0ZpcnN0UmVhZCA9IGZhbHNlO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbWFyayB0aGlzIG9uY2VcbiAgICAgICAgaWYgKCFwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogd2Ugc2hvdWxkIG9ubHkgbWFyayB0aGUgY2FjaGUgbm9kZSBhcyBkaXJ0eSBhZnRlciB3ZSB1bnN1c3BlbmQgZnJvbSB0aGUgY2FsbCBhYm92ZVxuICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlzRmlyc3RSZWFkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMuYWxpYXNlZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9hbGlhc2VkcHJlZmV0Y2huYXZpZ2F0aW9ucy5oYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSkoc3RhdGUsIGZsaWdodERhdGEsIHVybCwgbXV0YWJsZSk7XG4gICAgICAgICAgICAvLyBXZSBkaWRuJ3QgcmV0dXJuIG5ldyByb3V0ZXIgc3RhdGUgYmVjYXVzZSB3ZSBkaWRuJ3QgYXBwbHkgdGhlIGFsaWFzZWQgZW50cnkgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICAgICAgLy8gV2UnbGwgcmUtaW52b2tlIHRoZSBuYXZpZ2F0aW9uIGhhbmRsZXIgYnV0IGVuc3VyZSB0aGF0IHdlIGRvbid0IGF0dGVtcHQgdG8gdXNlIHRoZSBhbGlhc2VkIGVudHJ5LiBUaGlzXG4gICAgICAgICAgICAvLyB3aWxsIGNyZWF0ZSBhbiBvbi1kZW1hbmQgcHJlZmV0Y2ggZW50cnkuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0ZVJlZHVjZXIoc3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FsaWFzaW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZENhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgY29uc3Qgb25seUhhc2hDaGFuZ2UgPSAhIWhhc2ggJiYgc3RhdGUuY2Fub25pY2FsVXJsLnNwbGl0KCcjJywgMSlbMF0gPT09IHVwZGF0ZWRDYW5vbmljYWxVcmwuc3BsaXQoJyMnLCAxKVswXTtcbiAgICAgICAgLy8gSWYgb25seSB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlIHNlcnZlciBoYXNuJ3Qgc2VudCB1cyBhbnkgbmV3IGRhdGEuIFdlIGNhbiBqdXN0IHVwZGF0ZVxuICAgICAgICAvLyB0aGUgbXV0YWJsZSBwcm9wZXJ0aWVzIHJlc3BvbnNpYmxlIGZvciBVUkwgYW5kIHNjcm9sbCBoYW5kbGluZyBhbmQgcmV0dXJuIGVhcmx5LlxuICAgICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cGRhdGVkQ2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSBzaG91bGRTY3JvbGw7XG4gICAgICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2g7XG4gICAgICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhUb1NlZ21lbnQ6IGZsaWdodFNlZ21lbnRQYXRoLCBzZWVkRGF0YSwgaGVhZCwgaXNIZWFkUGFydGlhbCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YTtcbiAgICAgICAgICAgIGxldCB0cmVlUGF0Y2ggPSBub3JtYWxpemVkRmxpZ2h0RGF0YS50cmVlO1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5ID0gW1xuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICBsZXQgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCBocmVmKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmVlIHBhdGNoIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdHJlZSB0aGVuIHdlIHVzZSB0aGUgdHJlZSBhdCB0aW1lIG9mIHByZWZldGNoXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSwgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIHRyZWVQYXRjaCwgaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBhIHJvdXRlIGlzIFBQUmVkLCB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBzZW5kIGJhY2sgYSBzdGF0aWMgcmVzcG9uc2UgdGhhdCdzIHJlbmRlcmVkIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgcm9vdC4gSWYgZm9yIHNvbWUgcmVhc29uIGl0IGRvZXNuJ3QsIHdlIGZhbGwgYmFjayB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBnZXQgcmlkIG9mIHRoZSBlbHNlIGJyYW5jaCBhbmQgZG8gYWxsIG5hdmlnYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdmlhIHN0YXJ0UFBSTmF2aWdhdGlvbi4gVGhlIGN1cnJlbnQgc3RydWN0dXJlIGlzIGp1c3RcbiAgICAgICAgICAgICAgICAvLyBhbiBpbmNyZW1lbnRhbCBzdGVwLlxuICAgICAgICAgICAgICAgIHNlZWREYXRhICYmIGlzUm9vdFJlbmRlciAmJiBwb3N0cG9uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9ICgwLCBfcHBybmF2aWdhdGlvbnMuc3RhcnRQUFJOYXZpZ2F0aW9uKShjdXJyZW50Q2FjaGUsIGN1cnJlbnRUcmVlLCB0cmVlUGF0Y2gsIHNlZWREYXRhLCBoZWFkLCBpc0hlYWRQYXJ0aWFsLCBmYWxzZSwgc2Nyb2xsYWJsZVNlZ21lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0ZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LiBQZXJmb3JtIGFuIGZ1bGwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmVlIGNvbXB1dGVkIGJ5IHN0YXJ0UFBSTmF2aWdhdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgb25lIGNvbXB1dGVkIGJ5IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCByZW1vdmUgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBQUFIgcGF0aCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSb3V0ZXJTdGF0ZSA9IHRhc2sucm91dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUcmVlID0gcGF0Y2hlZFJvdXRlclN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSB0YXNrLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBjcmVhdGVkIGEgbmV3IENhY2hlIE5vZGUgdHJlZSB0aGF0IGNvbnRhaW5zIGEgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gb2YgdGhlIG5leHQgcGFnZS4gVGhpcyBjYW4gYmUgcmVuZGVyZWQgaW5zdGFudGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHRhc2suZHluYW1pY1JlcXVlc3RUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaGVkIHRyZWUgaGFzIGR5bmFtaWMgaG9sZXMgaW4gaXQuIFdlIGluaXRpYXRlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljIHJlcXVlc3QgdG8gZmlsbCB0aGVtIGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGJsb2NrIG9uIHRoZSByZXN1bHQuIFdlJ2xsIGltbWVkaWF0ZWx5IHJlbmRlciB0aGUgQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb2RlIHRyZWUgYW5kIHN1c3BlbmQgb24gdGhlIGR5bmFtaWMgcGFydHMuIFdoZW4gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1yZW5kZXIuIFVubGlrZSB0aGUgbGF6eSBmZXRjaGluZyBtb2RlbCBpbiB0aGUgbm9uLVBQUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB0aGlzIGlzIG1vZGVsZWQgYXMgYSBzaW5nbGUgUmVhY3QgdXBkYXRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGluIHRoZSBuZXcgbW9kZWwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gc29tZXRpbWVzIHVwZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByb290IG11bHRpcGxlIHRpbWVzIHBlciBuYXZpZ2F0aW9uLCBsaWtlIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsYXp5IGZldGNoaW5nIG1lY2hhbmlzbSBpbiB0aGF0IGNhc2UuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0ID0gKDAsIF9mZXRjaHNlcnZlcnJlc3BvbnNlLmZldGNoU2VydmVyUmVzcG9uc2UpKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogZHluYW1pY1JlcXVlc3RUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9wcHJuYXZpZ2F0aW9ucy5saXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCkodGFzaywgZHluYW1pY1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIGR5bmFtaWMgcmVxdWVzdCBvbiB0aGUgYGxhenlEYXRhYCBwcm9wZXJ0eSBvZiB0aGUgQ2FjaGVOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyB0byBhd2FpdCB0aGUgZHluYW1pYyByZXF1ZXN0IGhlcmUuIFNpbmNlIHdlJ3JlIG5vdCBibG9ja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIGR5bmFtaWMgcmVxdWVzdCwgYGxheW91dC1yb3V0ZXJgIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhc2subm9kZS5sYXp5RGF0YSA9IGR5bmFtaWNSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoZWQgdHJlZSBkb2VzIG5vdCBjb250YWluIGR5bmFtaWMgaG9sZXMg4oCUIGl0J3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGx5IHN0YXRpYy4gV2UgY2FuIHNraXAgdGhlIGR5bmFtaWMgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZCwgc28gcmV1c2UgdGhlIG9sZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgaWYgdGhlIGhlYWQgY2hhbmdlZCBidXQgbm90IGFueSBvZiB0aGUgc2VnbWVudCBkYXRhP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhhdCBwb3NzaWJsZT8gSWYgc28sIHdlIHNob3VsZCBjbG9uZSB0aGUgd2hvbGUgdHJlZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyZWUgPSB0cmVlUGF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3RhdGljIHJlc3BvbnNlIGRvZXMgbm90IGluY2x1ZGUgYW55IGR5bmFtaWMgaG9sZXMsIHNvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBkbyBhIHNlY29uZCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwIHRoaXMganVzdCByZXZlcnRzIGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uIFdlIGNhbiBzaW1wbGlmeSB0aGlzIGJyYW5jaCBmdXJ0aGVyLFxuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlbiB0aGF0IFBQUiBwcmVmZXRjaGVzIGFyZSBhbHdheXMgc3RhdGljIGFuZCByZXR1cm4gdGhlIHdob2xlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyZWUuIE9yIGluIHRoZSBtZWFudGltZSB3ZSBjb3VsZCBmYWN0b3IgaXQgb3V0IGludG8gYVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0LmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMuc3RhdHVzID09PSBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZSAmJiAhaXNGaXJzdFJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBhIHN0YWxlIHByZWZldGNoIGVudHJ5LCB3ZSBvbmx5IHdhbnQgdG8gcmUtdXNlIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSByb3V0ZSB3ZSdyZSBuYXZpZ2F0aW5nIHRvLCB0byBzdXBwb3J0IGluc3RhbnQgbG9hZGluZyBuYXZpZ2F0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGZvciB0aGUgYWN0dWFsIHBhZ2UgZGF0YSBieSBudWxsaW5nIHRoZSBgcnNjYCBhbmQgYHByZWZldGNoUnNjYCB2YWx1ZXMgZm9yIHBhZ2UgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIGNvcHlpbmcgb3ZlciB0aGUgYGxvYWRpbmdgIGZvciB0aGUgc2VnbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gc3Vic2VxdWVudCByZWFkcywgYXMgb3RoZXJ3aXNlIHRoZXJlJ2QgYmUgbm8gbG9hZGluZyBkYXRhIHRvIHJlLXVzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhpcyBicmFuY2ggaWYgb25seSB0aGUgaGFzaCBmcmFnbWVudCBoYXMgY2hhbmdlZCwgYXMgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBpbiB0aGF0IGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKGNhY2hlLCBjdXJyZW50Q2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgcmUtdXNlZCB0aGUgc3RhbGUgY2FjaGUncyBsb2FkaW5nIHN0YXRlICYgcmVmcmVzaGVkIHRoZSBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBgbGFzdFVzZWRUaW1lYCBzbyB0aGF0IGl0IGNhbiBjb250aW51ZSB0byBiZSByZS11c2VkIGZvciB0aGUgbmV4dCAzMHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkID0gKDAsIF9hcHBseWZsaWdodGRhdGEuYXBwbHlGbGlnaHREYXRhKShjdXJyZW50Q2FjaGUsIGNhY2hlLCBub3JtYWxpemVkRmxpZ2h0RGF0YSwgcHJlZmV0Y2hWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhcmROYXZpZ2F0ZSA9ICgwLCBfc2hvdWxkaGFyZG5hdmlnYXRlLnNob3VsZEhhcmROYXZpZ2F0ZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksIGN1cnJlbnRUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSByc2MgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9pbnZhbGlkYXRlY2FjaGViZWxvd2ZsaWdodHNlZ21lbnRwYXRoLmludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgpKGNhY2hlLCBjdXJyZW50Q2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZXhpc3RpbmcgY2FjaGUgdmFsdWUgaXMgdXNlZCB3aGVuIHRoZSBjYWNoZSB3YXMgbm90IGludmFsaWRhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFwcGxpZWQgdGhlIGNhY2hlLCB3ZSB1cGRhdGUgdGhlIFwiY3VycmVudCBjYWNoZVwiIHZhbHVlIHNvIGFueSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudHMgaW4gdGhlIEZsaWdodERhdGFQYXRoIHdpbGwgYmUgYWJsZSB0byByZWZlcmVuY2UgdGhlIHVwZGF0ZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVTZWdtZW50UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgX19ERUZBVUxUX18gcGF0aHMgYXMgdGhleSBzaG91bGRuJ3QgYmUgc2Nyb2xsZWQgdG8gaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09IF9zZWdtZW50LkRFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHMucHVzaChzY3JvbGxhYmxlU2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gY3VycmVudFRyZWU7XG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybDtcbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBzY3JvbGxhYmxlU2VnbWVudHM7XG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaDtcbiAgICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSBzaG91bGRTY3JvbGw7XG4gICAgICAgIHJldHVybiAoMCwgX2hhbmRsZW11dGFibGUuaGFuZGxlTXV0YWJsZSkoc3RhdGUsIG11dGFibGUpO1xuICAgIH0sICgpPT5zdGF0ZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRlLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsInJlcXVpcmUiLCJfY3JlYXRlaHJlZmZyb211cmwiLCJfaW52YWxpZGF0ZWNhY2hlYmVsb3dmbGlnaHRzZWdtZW50cGF0aCIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfc2hvdWxkaGFyZG5hdmlnYXRlIiwiX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJfaGFuZGxlbXV0YWJsZSIsIl9hcHBseWZsaWdodGRhdGEiLCJfcHJlZmV0Y2hyZWR1Y2VyIiwiX2FwcHJvdXRlciIsIl9zZWdtZW50IiwiX3Bwcm5hdmlnYXRpb25zIiwiX3ByZWZldGNoY2FjaGV1dGlscyIsIl9jbGVhcmNhY2hlbm9kZWRhdGFmb3JzZWdtZW50cGF0aCIsIl9hbGlhc2VkcHJlZmV0Y2huYXZpZ2F0aW9ucyIsIl9zZWdtZW50Y2FjaGUiLCJzdGF0ZSIsIm11dGFibGUiLCJ1cmwiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJzY3JvbGxhYmxlU2VnbWVudHMiLCJ1bmRlZmluZWQiLCJoYW5kbGVNdXRhYmxlIiwiZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCIsImZsaWdodFJvdXRlclBhdGNoIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInBhcmFsbGVsUm91dGUiLCJlbnRyaWVzIiwiY2hpbGRTZWdtZW50IiwicHVzaCIsInRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMiLCJuZXdDYWNoZSIsImN1cnJlbnRDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwiYXBwbGllZFBhdGNoIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJsb2FkaW5nIiwiTWFwIiwic2VnbWVudFBhdGhzVG9GaWxsIiwibWFwIiwic2VnbWVudFBhdGhzIiwiY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgiLCJoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0IiwicmVzdWx0IiwidGFnIiwiTmF2aWdhdGlvblJlc3VsdFRhZyIsIk1QQSIsIm5ld1VybCIsImRhdGEiLCJOb09wIiwibmV3Q2Fub25pY2FsVXJsIiwib2xkVXJsIiwiVVJMIiwib25seUhhc2hDaGFuZ2UiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJzaG91bGRTY3JvbGwiLCJoYXNoRnJhZ21lbnQiLCJTdWNjZXNzIiwiY2FjaGUiLCJjYWNoZU5vZGUiLCJwYXRjaGVkVHJlZSIsImZsaWdodFJvdXRlclN0YXRlIiwiQXN5bmMiLCJ0aGVuIiwiYXN5bmNSZXN1bHQiLCJhY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwibmF2aWdhdGVUeXBlIiwiYWxsb3dBbGlhc2luZyIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsInRvU3RyaW5nIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJuYXZpZ2F0ZSIsInRyZWUiLCJuZXh0VXJsIiwicHJlZmV0Y2hWYWx1ZXMiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwicHJlZmV0Y2hRdWV1ZSIsImJ1bXAiLCJwYXJhbSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInBvc3Rwb25lZCIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImFsaWFzZWQiLCJoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSIsInVwZGF0ZWRDYW5vbmljYWxVcmwiLCJzcGxpdCIsImN1cnJlbnRUcmVlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJwYXRoVG9TZWdtZW50Iiwic2VlZERhdGEiLCJoZWFkIiwiaXNIZWFkUGFydGlhbCIsImlzUm9vdFJlbmRlciIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJ0YXNrIiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwicm91dGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJub2RlIiwiZHluYW1pY1JlcXVlc3RUcmVlIiwiZHluYW1pY1JlcXVlc3QiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwibGlzdGVuRm9yRHluYW1pY1JlcXVlc3QiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/promise-queue.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nconst prefetchReducer =  false ? 0 : prefetchReducerImpl;\nfunction identityReducerWhenSegmentCacheIsEnabled(state) {\n    // Unlike the old implementation, the Segment Cache doesn't store its data in\n    // the router reducer state.\n    //\n    // This shouldn't be reachable because we wrap the prefetch API in a check,\n    // too, which prevents the action from being dispatched. But it's here for\n    // clarity + code elimination.\n    return state;\n}\nfunction prefetchReducerImpl(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        allowAliasing: true\n    });\n    return state;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCQyxtQkFBT0EsQ0FBQyw0R0FBcUI7QUFDbkQsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyxzSUFBeUI7QUFDN0QsTUFBTVQsZ0JBQWdCLElBQUlRLGNBQWNHLFlBQVksQ0FBQztBQUNyRCxNQUFNVixrQkFBa0JXLE1BQXVDLEdBQUdHLENBQXdDQSxHQUFHQztBQUM3RyxTQUFTRCx5Q0FBeUNFLEtBQUs7SUFDbkQsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsT0FBT0E7QUFDWDtBQUNBLFNBQVNELG9CQUFvQkMsS0FBSyxFQUFFQyxNQUFNO0lBQ3RDLDREQUE0RDtJQUMzRCxJQUFHUixvQkFBb0JTLGtCQUFrQixFQUFFRixNQUFNRyxhQUFhO0lBQy9ELE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdIO0lBQ2YsSUFBR1Isb0JBQW9CWSw2QkFBNkIsRUFBRTtRQUNuREQ7UUFDQUUsU0FBU04sTUFBTU0sT0FBTztRQUN0QkgsZUFBZUgsTUFBTUcsYUFBYTtRQUNsQ0ksTUFBTU4sT0FBT00sSUFBSTtRQUNqQkMsTUFBTVIsTUFBTVEsSUFBSTtRQUNoQkMsZUFBZTtJQUNuQjtJQUNBLE9BQU9UO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT3BCLFFBQVE4QixPQUFPLEtBQUssY0FBZSxPQUFPOUIsUUFBUThCLE9BQU8sS0FBSyxZQUFZOUIsUUFBUThCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlCLFFBQVE4QixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakMsT0FBT0MsY0FBYyxDQUFDQyxRQUFROEIsT0FBTyxFQUFFLGNBQWM7UUFBRTdCLE9BQU87SUFBSztJQUNuRUgsT0FBT2tDLE1BQU0sQ0FBQ2hDLFFBQVE4QixPQUFPLEVBQUU5QjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFROEIsT0FBTztBQUNsQyxFQUVBLDRDQUE0QyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBudWxsLFxuICAgIHByZWZldGNoUmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBwcmVmZXRjaFF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoUXVldWU7XG4gICAgfSxcbiAgICBwcmVmZXRjaFJlZHVjZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hSZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX3Byb21pc2VxdWV1ZSA9IHJlcXVpcmUoXCIuLi8uLi9wcm9taXNlLXF1ZXVlXCIpO1xuY29uc3QgX3ByZWZldGNoY2FjaGV1dGlscyA9IHJlcXVpcmUoXCIuLi9wcmVmZXRjaC1jYWNoZS11dGlsc1wiKTtcbmNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgX3Byb21pc2VxdWV1ZS5Qcm9taXNlUXVldWUoNSk7XG5jb25zdCBwcmVmZXRjaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgPyBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkIDogcHJlZmV0Y2hSZWR1Y2VySW1wbDtcbmZ1bmN0aW9uIGlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQoc3RhdGUpIHtcbiAgICAvLyBVbmxpa2UgdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgdGhlIFNlZ21lbnQgQ2FjaGUgZG9lc24ndCBzdG9yZSBpdHMgZGF0YSBpblxuICAgIC8vIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZS5cbiAgICAvL1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSBiZWNhdXNlIHdlIHdyYXAgdGhlIHByZWZldGNoIEFQSSBpbiBhIGNoZWNrLFxuICAgIC8vIHRvbywgd2hpY2ggcHJldmVudHMgdGhlIGFjdGlvbiBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuIEJ1dCBpdCdzIGhlcmUgZm9yXG4gICAgLy8gY2xhcml0eSArIGNvZGUgZWxpbWluYXRpb24uXG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VySW1wbChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgLy8gbGV0J3MgcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIGJlZm9yZSB3ZSBkbyBhbnl0aGluZyBlbHNlXG4gICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMucHJ1bmVQcmVmZXRjaENhY2hlKShzdGF0ZS5wcmVmZXRjaENhY2hlKTtcbiAgICBjb25zdCB7IHVybCB9ID0gYWN0aW9uO1xuICAgICgwLCBfcHJlZmV0Y2hjYWNoZXV0aWxzLmdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAga2luZDogYWN0aW9uLmtpbmQsXG4gICAgICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgICAgIGFsbG93QWxpYXNpbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZldGNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwicHJlZmV0Y2hRdWV1ZSIsInByZWZldGNoUmVkdWNlciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9wcm9taXNlcXVldWUiLCJyZXF1aXJlIiwiX3ByZWZldGNoY2FjaGV1dGlscyIsIlByb21pc2VRdWV1ZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkIiwicHJlZmV0Y2hSZWR1Y2VySW1wbCIsInN0YXRlIiwiYWN0aW9uIiwicHJ1bmVQcmVmZXRjaENhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInVybCIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwibmV4dFVybCIsImtpbmQiLCJ0cmVlIiwiYWxsb3dBbGlhc2luZyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"refreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    return cache.lazyData.then(async (param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7SUFDN0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx1QkFBdUJDLG1CQUFPQSxDQUFDLHdJQUEwQjtBQUMvRCxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM1RCxNQUFNRSwrQkFBK0JGLG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNRywrQkFBK0JILG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNSSxtQkFBbUJKLG1CQUFPQSxDQUFDLHNJQUFvQjtBQUNyRCxNQUFNSyxpQkFBaUJMLG1CQUFPQSxDQUFDLDBIQUFtQjtBQUNsRCxNQUFNTSxpQ0FBaUNOLG1CQUFPQSxDQUFDLG9LQUF3QztBQUN2RixNQUFNTyxhQUFhUCxtQkFBT0EsQ0FBQyxzR0FBa0I7QUFDN0MsTUFBTVEseUJBQXlCUixtQkFBT0EsQ0FBQyw0SUFBNEI7QUFDbkUsTUFBTVMscUNBQXFDVCxtQkFBT0EsQ0FBQyxrTEFBMEM7QUFDN0YsTUFBTVUsbUNBQW1DVixtQkFBT0EsQ0FBQyxrS0FBdUM7QUFDeEYsTUFBTVcsZ0JBQWdCWCxtQkFBT0EsQ0FBQyw0R0FBcUI7QUFDbkQsU0FBU0YsZUFBZWMsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdEO0lBQ25CLE1BQU1FLFVBQVUsQ0FBQztJQUNqQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBQy9CLElBQUlDLGNBQWNOLE1BQU1PLElBQUk7SUFDNUJKLFFBQVFLLDBCQUEwQixHQUFHO0lBQ3JDLE1BQU1D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O1FBQ2xCO1FBQ0EsT0FBTyxDQUFDLEdBQUd4QyxlQUFlNkQsYUFBYSxFQUFFdEQsT0FBT0c7SUFDcEQsR0FBRyxJQUFJSDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9sQixRQUFReUUsT0FBTyxLQUFLLGNBQWUsT0FBT3pFLFFBQVF5RSxPQUFPLEtBQUssWUFBWXpFLFFBQVF5RSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU96RSxRQUFReUUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzVFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXlFLE9BQU8sRUFBRSxjQUFjO1FBQUV4RSxPQUFPO0lBQUs7SUFDbkVILE9BQU82RSxNQUFNLENBQUMzRSxRQUFReUUsT0FBTyxFQUFFekU7SUFDL0I0RSxPQUFPNUUsT0FBTyxHQUFHQSxRQUFReUUsT0FBTztBQUNsQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZnJlc2hSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZWZyZXNoUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4uL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG5jb25zdCBfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuY29uc3QgX25hdmlnYXRlcmVkdWNlciA9IHJlcXVpcmUoXCIuL25hdmlnYXRlLXJlZHVjZXJcIik7XG5jb25zdCBfaGFuZGxlbXV0YWJsZSA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtbXV0YWJsZVwiKTtcbmNvbnN0IF9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZCA9IHJlcXVpcmUoXCIuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmNvbnN0IF9hcHByb3V0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYXBwLXJvdXRlclwiKTtcbmNvbnN0IF9oYW5kbGVzZWdtZW50bWlzbWF0Y2ggPSByZXF1aXJlKFwiLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2hcIik7XG5jb25zdCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlID0gcmVxdWlyZShcIi4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWVcIik7XG5jb25zdCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzXCIpO1xuY29uc3QgX3NlZ21lbnRjYWNoZSA9IHJlcXVpcmUoXCIuLi8uLi9zZWdtZW50LWNhY2hlXCIpO1xuZnVuY3Rpb24gcmVmcmVzaFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbXV0YWJsZSA9IHt9O1xuICAgIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmw7XG4gICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgY2FjaGUgPSAoMCwgX2FwcHJvdXRlci5jcmVhdGVFbXB0eUNhY2hlTm9kZSkoKTtcbiAgICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAgIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgICBjb25zdCBpbmNsdWRlTmV4dFVybCA9ICgwLCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlLmhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSkoc3RhdGUudHJlZSk7XG4gICAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICBjYWNoZS5sYXp5RGF0YSA9ICgwLCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlWzBdLFxuICAgICAgICAgICAgY3VycmVudFRyZWVbMV0sXG4gICAgICAgICAgICBjdXJyZW50VHJlZVsyXSxcbiAgICAgICAgICAgICdyZWZldGNoJ1xuICAgICAgICBdLFxuICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oYXN5bmMgKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlIH0gPSBwYXJhbTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBjYWNoZS5sYXp5RGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLCBoZWFkLCBpc1Jvb3RSZW5kZXIgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhO1xuICAgICAgICAgICAgaWYgKCFpc1Jvb3RSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIHRoaXMgY2FzZSBiZXR0ZXJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgIF0sIGN1cnJlbnRUcmVlLCB0cmVlUGF0Y2gsIHN0YXRlLmNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaC5oYW5kbGVTZWdtZW50TWlzbWF0Y2gpKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KShjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgcHJlZmV0Y2ggb25seSByZXR1cm5zIHRoZSByb3V0ZXIgdHJlZSBwYXRjaCB3aXRob3V0IHJlbmRlcmVkIGNvbXBvbmVudHMuXG4gICAgICAgICAgICBpZiAoY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM107XG4gICAgICAgICAgICAgICAgY2FjaGUucnNjID0gcnNjO1xuICAgICAgICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZztcbiAgICAgICAgICAgICAgICAoMCwgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKShjYWNoZSwgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBgcm91dGVyLnJlZnJlc2goKWAgaGFzIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHRyZWVQYXRjaCwgY2FjaGVOb2RlU2VlZERhdGEsIGhlYWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NlZ21lbnRjYWNoZS5yZXZhbGlkYXRlRW50aXJlQ2FjaGUpKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgX3JlZmV0Y2hpbmFjdGl2ZXBhcmFsbGVsc2VnbWVudHMucmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cykoe1xuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZU5leHRVcmwsXG4gICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlbXV0YWJsZS5oYW5kbGVNdXRhYmxlKShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfSwgKCk9PnN0YXRlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmcmVzaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZWZyZXNoUmVkdWNlciIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwicmVxdWlyZSIsIl9jcmVhdGVocmVmZnJvbXVybCIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX25hdmlnYXRlcmVkdWNlciIsIl9oYW5kbGVtdXRhYmxlIiwiX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkIiwiX2FwcHJvdXRlciIsIl9oYW5kbGVzZWdtZW50bWlzbWF0Y2giLCJfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlIiwiX3JlZmV0Y2hpbmFjdGl2ZXBhcmFsbGVsc2VnbWVudHMiLCJfc2VnbWVudGNhY2hlIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImN1cnJlbnRUcmVlIiwidHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwidGhlbiIsInBhcmFtIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7SUFDN0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxxQkFBcUJDLG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM1RCxNQUFNQyxzQkFBc0JELG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM3RCxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLDRIQUFvQjtBQUNwRCxTQUFTRixlQUFlSyxLQUFLLEVBQUVDLE1BQU07SUFDakMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHRjtJQUN0QixNQUFNRyxPQUFPLENBQUMsR0FBR1IsbUJBQW1CUyxpQkFBaUIsRUFBRUg7SUFDdkQsMEVBQTBFO0lBQzFFLDRGQUE0RjtJQUM1RixnR0FBZ0c7SUFDaEcsNkZBQTZGO0lBQzdGLDhEQUE4RDtJQUM5RCx5R0FBeUc7SUFDekcsTUFBTUksZ0JBQWdCSCxRQUFRSCxNQUFNRyxJQUFJO0lBQ3hDLE1BQU1JLFdBQVdQLE1BQU1RLEtBQUs7SUFDNUIsTUFBTUMsV0FBV0MsTUFBc0IsR0FHdkMsMkRBRjJEO0lBQzNELDJCQUEyQjtJQUMxQixDQUFpRkosR0FBR0M7SUFDckYsSUFBSU87SUFDSixPQUFPO1FBQ0gsb0JBQW9CO1FBQ3BCQyxjQUFjWDtRQUNkWSxTQUFTO1lBQ0xDLGFBQWE7WUFDYkMsZUFBZTtZQUNmLDZGQUE2RjtZQUM3RkMsNEJBQTRCO1FBQ2hDO1FBQ0FDLG1CQUFtQnBCLE1BQU1vQixpQkFBaUI7UUFDMUNaLE9BQU9DO1FBQ1BZLGVBQWVyQixNQUFNcUIsYUFBYTtRQUNsQyx3QkFBd0I7UUFDeEJsQixNQUFNRztRQUNOZ0IsU0FBUyxDQUFDUixvQ0FBb0MsQ0FBQyxHQUFHaEIsb0JBQW9CeUIsZ0NBQWdDLEVBQUVqQixjQUFhLEtBQU0sT0FBT1Esb0NBQW9DWixJQUFJc0IsUUFBUTtJQUN0TDtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9qQyxRQUFRa0MsT0FBTyxLQUFLLGNBQWUsT0FBT2xDLFFBQVFrQyxPQUFPLEtBQUssWUFBWWxDLFFBQVFrQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9sQyxRQUFRa0MsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3JDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWtDLE9BQU8sRUFBRSxjQUFjO1FBQUVqQyxPQUFPO0lBQUs7SUFDbkVILE9BQU9zQyxNQUFNLENBQUNwQyxRQUFRa0MsT0FBTyxFQUFFbEM7SUFDL0JxQyxPQUFPckMsT0FBTyxHQUFHQSxRQUFRa0MsT0FBTztBQUNsQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc3RvcmVSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXN0b3JlUmVkdWNlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9jcmVhdGVocmVmZnJvbXVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmNvbnN0IF9jb21wdXRlY2hhbmdlZHBhdGggPSByZXF1aXJlKFwiLi4vY29tcHV0ZS1jaGFuZ2VkLXBhdGhcIik7XG5jb25zdCBfcHBybmF2aWdhdGlvbnMgPSByZXF1aXJlKFwiLi4vcHByLW5hdmlnYXRpb25zXCIpO1xuZnVuY3Rpb24gcmVzdG9yZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgdXJsLCB0cmVlIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKHVybCk7XG4gICAgLy8gVGhpcyBhY3Rpb24gaXMgdXNlZCB0byByZXN0b3JlIHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAgIC8vIFdlIHdpbGwgY29weSBvdmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGV2ZW50cywgYnV0IGlmIGEgaGlzdG9yeSBlbnRyeVxuICAgIC8vIG9jY3VycmVkIGJlZm9yZSBoeWRyYXRpb24sIG9yIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCB0byBhIGhhc2ggdXNpbmcgYSByZWd1bGFyIGFuY2hvciBsaW5rLFxuICAgIC8vIHRoZSBoaXN0b3J5IHN0YXRlIHdpbGwgbm90IGNvbnRhaW4gdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdsbCBjb250aW51ZSB0byB1c2UgdGhlIGV4aXN0aW5nIHRyZWUgc28gdGhlIHJvdXRlciBkb2Vzbid0IGdldCBpbnRvIGFuIGludmFsaWQgc3RhdGUuXG4gICAgY29uc3QgdHJlZVRvUmVzdG9yZSA9IHRyZWUgfHwgc3RhdGUudHJlZTtcbiAgICBjb25zdCBvbGRDYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgIGNvbnN0IG5ld0NhY2hlID0gcHJvY2Vzcy5lbnYuX19ORVhUX1BQUiA/IC8vIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWMgZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSIHN0YXRlIGR1cmluZyBhXG4gICAgLy8gYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gICAgKDAsIF9wcHJuYXZpZ2F0aW9ucy51cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24pKG9sZENhY2hlLCB0cmVlVG9SZXN0b3JlKSA6IG9sZENhY2hlO1xuICAgIHZhciBfZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2V0IGNhbm9uaWNhbCB1cmxcbiAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgY3VzdG9tIGhpc3Rvcnkgc3RhdGUgdGhhdCB3YXMgc2V0IGlzIHByZXNlcnZlZCB3aGVuIGFwcGx5aW5nIHRoaXMgdXBkYXRlLlxuICAgICAgICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjYWNoZTogbmV3Q2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICB0cmVlOiB0cmVlVG9SZXN0b3JlLFxuICAgICAgICBuZXh0VXJsOiAoX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlID0gKDAsIF9jb21wdXRlY2hhbmdlZHBhdGguZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUpKHRyZWVUb1Jlc3RvcmUpKSAhPSBudWxsID8gX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIDogdXJsLnBhdGhuYW1lXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdG9yZS1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXN0b3JlUmVkdWNlciIsIl9jcmVhdGVocmVmZnJvbXVybCIsInJlcXVpcmUiLCJfY29tcHV0ZWNoYW5nZWRwYXRoIiwiX3Bwcm5hdmlnYXRpb25zIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidHJlZVRvUmVzdG9yZSIsIm9sZENhY2hlIiwiY2FjaGUiLCJuZXdDYWNoZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUFBSIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiX2V4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJwcmVmZXRjaENhY2hlIiwibmV4dFVybCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwicGF0aG5hbWUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _assignlocation = __webpack_require__(/*! ../../../assign-location */ \"(app-pages-browser)/./node_modules/next/dist/client/assign-location.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _redirect = __webpack_require__(/*! ../../redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ../../redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _serverreferenceinfo = __webpack_require__(/*! ../../../../shared/lib/server-reference-info */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/server-reference-info.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await encodeReply(usedArgs, {\n        temporaryReferences\n    });\n    const res = await fetch('', {\n        method: 'POST',\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION_HEADER]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    if (contentType == null ? void 0 : contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            return {\n                actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n                redirectLocation,\n                redirectType,\n                revalidatedParts,\n                isPrerender\n            };\n        }\n        return {\n            actionResult: response.a,\n            actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            redirectLocation,\n            redirectType,\n            revalidatedParts,\n            isPrerender\n        };\n    }\n    // Handle invalid server action responses\n    if (res.status >= 400) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const error = contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(error), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    return fetchServerAction(state, nextUrl, action).then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === _redirecterror.RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                resolve(actionResult);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[3];\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                mutable.cache = cache;\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n                if (actionRevalidated) {\n                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            if ( true && !actionRevalidated) {\n                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n                // with the FlightData that we got from the server action for the target page, so that it's\n                // available when the page is navigated to and doesn't need to be re-fetched.\n                // We only do this if the server action didn't revalidate any data, as in that case the\n                // client cache will be cleared and the data will be re-fetched anyway.\n                // NOTE: We don't do this in the Segment Cache implementation.\n                // Dynamic data should never be placed into the cache, unless it's\n                // \"converted\" to static data using <Link prefetch={true}>. What we\n                // do instead is re-prefetch links and forms whenever the cache is\n                // invalidated.\n                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({\n                    url: redirectLocation,\n                    data: {\n                        flightData,\n                        canonicalUrl: undefined,\n                        couldBeIntercepted: false,\n                        prerendered: false,\n                        postponed: false,\n                        // TODO: We should be able to set this if the server action\n                        // returned a fully static response.\n                        staleTime: -1\n                    },\n                    tree: state.tree,\n                    prefetchCache: state.prefetchCache,\n                    nextUrl: state.nextUrl,\n                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO\n                });\n                mutable.prefetchCache = state.prefetchCache;\n            }\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));\n        } else {\n            resolve(actionResult);\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCx1REFBc0Q7SUFDbERJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHdHQUEwQjtBQUN6RCxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLHdIQUFrQztBQUN2RSxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDLHNIQUEwQjtBQUM1RCxNQUFNRyxzQkFBc0JILG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM3RCxNQUFNSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHdHQUEwQjtBQUMxRCxNQUFNSyxxQkFBcUJMLG1CQUFPQSxDQUFDLHNJQUF5QjtBQUM1RCxNQUFNTSxtQkFBbUJOLG1CQUFPQSxDQUFDLHNJQUFvQjtBQUNyRCxNQUFNTywrQkFBK0JQLG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNUSwrQkFBK0JSLG1CQUFPQSxDQUFDLDhKQUFxQztBQUNsRixNQUFNUyxpQkFBaUJULG1CQUFPQSxDQUFDLDBIQUFtQjtBQUNsRCxNQUFNVSxpQ0FBaUNWLG1CQUFPQSxDQUFDLG9LQUF3QztBQUN2RixNQUFNVyxhQUFhWCxtQkFBT0EsQ0FBQyxzR0FBa0I7QUFDN0MsTUFBTVkscUNBQXFDWixtQkFBT0EsQ0FBQyxrTEFBMEM7QUFDN0YsTUFBTWEseUJBQXlCYixtQkFBT0EsQ0FBQyw0SUFBNEI7QUFDbkUsTUFBTWMsbUNBQW1DZCxtQkFBT0EsQ0FBQyxrS0FBdUM7QUFDeEYsTUFBTWUscUJBQXFCZixtQkFBT0EsQ0FBQyxnSEFBOEI7QUFDakUsTUFBTWdCLFlBQVloQixt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QUs7SUFDbkVILE9BQU9xSyxNQUFNLENBQUNuSyxRQUFRaUssT0FBTyxFQUFFaks7SUFDL0JvSyxPQUFPcEssT0FBTyxHQUFHQSxRQUFRaUssT0FBTztBQUNsQyxFQUVBLGlEQUFpRCIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcnZlckFjdGlvblJlZHVjZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckFjdGlvblJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfYXBwY2FsbHNlcnZlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hcHAtY2FsbC1zZXJ2ZXJcIik7XG5jb25zdCBfYXBwZmluZHNvdXJjZW1hcHVybCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybFwiKTtcbmNvbnN0IF9hcHByb3V0ZXJoZWFkZXJzID0gcmVxdWlyZShcIi4uLy4uL2FwcC1yb3V0ZXItaGVhZGVyc1wiKTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi4vcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBfYXNzaWdubG9jYXRpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vYXNzaWduLWxvY2F0aW9uXCIpO1xuY29uc3QgX2NyZWF0ZWhyZWZmcm9tdXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuY29uc3QgX25hdmlnYXRlcmVkdWNlciA9IHJlcXVpcmUoXCIuL25hdmlnYXRlLXJlZHVjZXJcIik7XG5jb25zdCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2ZpbGxsYXp5aXRlbXN0aWxsbGVhZndpdGhoZWFkID0gcmVxdWlyZShcIi4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuY29uc3QgX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSA9IHJlcXVpcmUoXCIuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlXCIpO1xuY29uc3QgX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCA9IHJlcXVpcmUoXCIuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaFwiKTtcbmNvbnN0IF9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzID0gcmVxdWlyZShcIi4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHNcIik7XG5jb25zdCBfZmxpZ2h0ZGF0YWhlbHBlcnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVyc1wiKTtcbmNvbnN0IF9yZWRpcmVjdCA9IHJlcXVpcmUoXCIuLi8uLi9yZWRpcmVjdFwiKTtcbmNvbnN0IF9yZWRpcmVjdGVycm9yID0gcmVxdWlyZShcIi4uLy4uL3JlZGlyZWN0LWVycm9yXCIpO1xuY29uc3QgX3ByZWZldGNoY2FjaGV1dGlscyA9IHJlcXVpcmUoXCIuLi9wcmVmZXRjaC1jYWNoZS11dGlsc1wiKTtcbmNvbnN0IF9yZW1vdmViYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9yZW1vdmUtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfc2VydmVycmVmZXJlbmNlaW5mbyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mb1wiKTtcbmNvbnN0IF9zZWdtZW50Y2FjaGUgPSByZXF1aXJlKFwiLi4vLi4vc2VnbWVudC1jYWNoZVwiKTtcbi8vIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbi8vIGltcG9ydCB7IGNyZWF0ZUZyb21GZXRjaCB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG4vLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBlbmNvZGVSZXBseSB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG5jb25zdCB7IGNyZWF0ZUZyb21GZXRjaCwgY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0LCBlbmNvZGVSZXBseSB9ID0gISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPyByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmVkZ2UnKSA6IHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnKTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHN0YXRlLCBuZXh0VXJsLCBwYXJhbSkge1xuICAgIGxldCB7IGFjdGlvbklkLCBhY3Rpb25BcmdzIH0gPSBwYXJhbTtcbiAgICBjb25zdCB0ZW1wb3JhcnlSZWZlcmVuY2VzID0gY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0KCk7XG4gICAgY29uc3QgaW5mbyA9ICgwLCBfc2VydmVycmVmZXJlbmNlaW5mby5leHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZCkoYWN0aW9uSWQpO1xuICAgIC8vIFRPRE86IEN1cnJlbnRseSwgd2UncmUgb25seSBvbWl0dGluZyB1bnVzZWQgYXJncyBmb3IgdGhlIGV4cGVyaW1lbnRhbCBcInVzZVxuICAgIC8vIGNhY2hlXCIgZnVuY3Rpb25zLiBPbmNlIHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBmZWF0dXJlIGlzIHN0YWJsZSwgd2VcbiAgICAvLyBzaG91bGQgYXBwbHkgdGhpcyB0byBzZXJ2ZXIgYWN0aW9ucyBhcyB3ZWxsLlxuICAgIGNvbnN0IHVzZWRBcmdzID0gaW5mby50eXBlID09PSAndXNlLWNhY2hlJyA/ICgwLCBfc2VydmVycmVmZXJlbmNlaW5mby5vbWl0VW51c2VkQXJncykoYWN0aW9uQXJncywgaW5mbykgOiBhY3Rpb25BcmdzO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBlbmNvZGVSZXBseSh1c2VkQXJncywge1xuICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEFjY2VwdDogX2FwcHJvdXRlcmhlYWRlcnMuUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gICAgICAgICAgICBbX2FwcHJvdXRlcmhlYWRlcnMuQUNUSU9OX0hFQURFUl06IGFjdGlvbklkLFxuICAgICAgICAgICAgW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKSxcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCA/IHtcbiAgICAgICAgICAgICAgICAneC1kZXBsb3ltZW50LWlkJzogcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAuLi5uZXh0VXJsID8ge1xuICAgICAgICAgICAgICAgIFtfYXBwcm91dGVyaGVhZGVycy5ORVhUX1VSTF06IG5leHRVcmxcbiAgICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9LFxuICAgICAgICBib2R5XG4gICAgfSk7XG4gICAgY29uc3QgcmVkaXJlY3RIZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJlZGlyZWN0Jyk7XG4gICAgY29uc3QgW2xvY2F0aW9uLCBfcmVkaXJlY3RUeXBlXSA9IChyZWRpcmVjdEhlYWRlciA9PSBudWxsID8gdm9pZCAwIDogcmVkaXJlY3RIZWFkZXIuc3BsaXQoJzsnKSkgfHwgW107XG4gICAgbGV0IHJlZGlyZWN0VHlwZTtcbiAgICBzd2l0Y2goX3JlZGlyZWN0VHlwZSl7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgcmVkaXJlY3RUeXBlID0gX3JlZGlyZWN0ZXJyb3IuUmVkaXJlY3RUeXBlLnB1c2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICByZWRpcmVjdFR5cGUgPSBfcmVkaXJlY3RlcnJvci5SZWRpcmVjdFR5cGUucmVwbGFjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVkaXJlY3RUeXBlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBpc1ByZXJlbmRlciA9ICEhcmVzLmhlYWRlcnMuZ2V0KF9hcHByb3V0ZXJoZWFkZXJzLk5FWFRfSVNfUFJFUkVOREVSX0hFQURFUik7XG4gICAgbGV0IHJldmFsaWRhdGVkUGFydHM7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV2YWxpZGF0ZWRIZWFkZXIgPSBKU09OLnBhcnNlKHJlcy5oZWFkZXJzLmdldCgneC1hY3Rpb24tcmV2YWxpZGF0ZWQnKSB8fCAnW1tdLDAsMF0nKTtcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IHtcbiAgICAgICAgICAgIHBhdGhzOiByZXZhbGlkYXRlZEhlYWRlclswXSB8fCBbXSxcbiAgICAgICAgICAgIHRhZzogISFyZXZhbGlkYXRlZEhlYWRlclsxXSxcbiAgICAgICAgICAgIGNvb2tpZTogcmV2YWxpZGF0ZWRIZWFkZXJbMl1cbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMgPSB7XG4gICAgICAgICAgICBwYXRoczogW10sXG4gICAgICAgICAgICB0YWc6IGZhbHNlLFxuICAgICAgICAgICAgY29va2llOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdExvY2F0aW9uID0gbG9jYXRpb24gPyAoMCwgX2Fzc2lnbmxvY2F0aW9uLmFzc2lnbkxvY2F0aW9uKShsb2NhdGlvbiwgbmV3IFVSTChzdGF0ZS5jYW5vbmljYWxVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgIGlmIChjb250ZW50VHlwZSA9PSBudWxsID8gdm9pZCAwIDogY29udGVudFR5cGUuc3RhcnRzV2l0aChfYXBwcm91dGVyaGVhZGVycy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUikpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVGcm9tRmV0Y2goUHJvbWlzZS5yZXNvbHZlKHJlcyksIHtcbiAgICAgICAgICAgIGNhbGxTZXJ2ZXI6IF9hcHBjYWxsc2VydmVyLmNhbGxTZXJ2ZXIsXG4gICAgICAgICAgICBmaW5kU291cmNlTWFwVVJMOiBfYXBwZmluZHNvdXJjZW1hcHVybC5maW5kU291cmNlTWFwVVJMLFxuICAgICAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCB3YXMgYSByZWRpcmVjdGlvbiwgdGhlbiByZXN1bHQgaXMganVzdCBhIHJlZ3VsYXIgUlNDIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uRmxpZ2h0RGF0YTogKDAsIF9mbGlnaHRkYXRhaGVscGVycy5ub3JtYWxpemVGbGlnaHREYXRhKShyZXNwb25zZS5mKSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlZFBhcnRzLFxuICAgICAgICAgICAgICAgIGlzUHJlcmVuZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Rpb25SZXN1bHQ6IHJlc3BvbnNlLmEsXG4gICAgICAgICAgICBhY3Rpb25GbGlnaHREYXRhOiAoMCwgX2ZsaWdodGRhdGFoZWxwZXJzLm5vcm1hbGl6ZUZsaWdodERhdGEpKHJlc3BvbnNlLmYpLFxuICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgICAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgICAgICAgICBpc1ByZXJlbmRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgaW52YWxpZCBzZXJ2ZXIgYWN0aW9uIHJlc3BvbnNlc1xuICAgIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAvLyBUaGUgc2VydmVyIGNhbiByZXNwb25kIHdpdGggYSB0ZXh0L3BsYWluIGVycm9yIG1lc3NhZ2UsIGJ1dCB3ZSdsbCBmYWxsYmFjayB0byBzb21ldGhpbmcgZ2VuZXJpY1xuICAgICAgICAvLyBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAgICAgIGNvbnN0IGVycm9yID0gY29udGVudFR5cGUgPT09ICd0ZXh0L3BsYWluJyA/IGF3YWl0IHJlcy50ZXh0KCkgOiAnQW4gdW5leHBlY3RlZCByZXNwb25zZSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLic7XG4gICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoZXJyb3IpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkUzOTRcIixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICByZWRpcmVjdFR5cGUsXG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgICAgIGlzUHJlcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlckFjdGlvblJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBhY3Rpb247XG4gICAgY29uc3QgbXV0YWJsZSA9IHt9O1xuICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlO1xuICAgIC8vIG9ubHkgcGFzcyBhbG9uZyB0aGUgYG5leHRVcmxgIHBhcmFtICh1c2VkIGZvciBpbnRlcmNlcHRpb24gcm91dGVzKSBpZiB0aGUgY3VycmVudCByb3V0ZSB3YXMgaW50ZXJjZXB0ZWQuXG4gICAgLy8gSWYgdGhlIHJvdXRlIGhhcyBiZWVuIGludGVyY2VwdGVkLCB0aGUgYWN0aW9uIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAgIC8vIE90aGVyd2lzZSB0aGUgc2VydmVyIGFjdGlvbiBtaWdodCBiZSBpbnRlcmNlcHRlZCB3aXRoIHRoZSB3cm9uZyBhY3Rpb24gaWRcbiAgICAvLyAoaWUsIG9uZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGludGVyY2VwdGVkIHJvdXRlKVxuICAgIGNvbnN0IG5leHRVcmwgPSBzdGF0ZS5uZXh0VXJsICYmICgwLCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlLmhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSkoc3RhdGUudHJlZSkgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbDtcbiAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc3RhdGUsIG5leHRVcmwsIGFjdGlvbikudGhlbihhc3luYyAocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGFjdGlvblJlc3VsdCwgYWN0aW9uRmxpZ2h0RGF0YTogZmxpZ2h0RGF0YSwgcmVkaXJlY3RMb2NhdGlvbiwgcmVkaXJlY3RUeXBlLCBpc1ByZXJlbmRlciwgcmV2YWxpZGF0ZWRQYXJ0cyB9ID0gcGFyYW07XG4gICAgICAgIGxldCByZWRpcmVjdEhyZWY7XG4gICAgICAgIC8vIGhvbm9yIHRoZSByZWRpcmVjdCB0eXBlIGluc3RlYWQgb2YgZGVmYXVsdGluZyB0byBwdXNoIGluIGNhc2Ugb2Ygc2VydmVyIGFjdGlvbnMuXG4gICAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBfcmVkaXJlY3RlcnJvci5SZWRpcmVjdFR5cGUucmVwbGFjZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkaXJlY3RIcmVmID0gKDAsIF9jcmVhdGVocmVmZnJvbXVybC5jcmVhdGVIcmVmRnJvbVVybCkocmVkaXJlY3RMb2NhdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSByZWRpcmVjdEhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbGlnaHREYXRhKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IGJ1dCBubyBmbGlnaHQgZGF0YSB3ZSBuZWVkIHRvIGRvIGEgbXBhTmF2aWdhdGlvbi5cbiAgICAgICAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgcmVkaXJlY3RMb2NhdGlvbi5ocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5oYW5kbGVFeHRlcm5hbFVybCkoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvblJldmFsaWRhdGVkID0gcmV2YWxpZGF0ZWRQYXJ0cy5wYXRocy5sZW5ndGggPiAwIHx8IHJldmFsaWRhdGVkUGFydHMudGFnIHx8IHJldmFsaWRhdGVkUGFydHMuY29va2llO1xuICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpe1xuICAgICAgICAgICAgY29uc3QgeyB0cmVlOiB0cmVlUGF0Y2gsIHNlZWREYXRhOiBjYWNoZU5vZGVTZWVkRGF0YSwgaGVhZCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YTtcbiAgICAgICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NFUlZFUiBBQ1RJT04gQVBQTFkgRkFJTEVEJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCByc2MgZm9yIHRoZSByb290LlxuICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICBdLCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCByZWRpcmVjdEhyZWYgPyByZWRpcmVjdEhyZWYgOiBzdGF0ZS5jYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfaGFuZGxlc2VnbWVudG1pc21hdGNoLmhhbmRsZVNlZ21lbnRNaXNtYXRjaCkoc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCByZWRpcmVjdEhyZWYgfHwgc3RhdGUuY2Fub25pY2FsVXJsLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VudCBiYWNrIFJTQyBkYXRhIGZvciB0aGUgc2VydmVyIGFjdGlvbiwgc28gd2UgbmVlZCB0byBhcHBseSBpdCB0byB0aGUgY2FjaGUuXG4gICAgICAgICAgICBpZiAoY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBfYXBwcm91dGVyLmNyZWF0ZUVtcHR5Q2FjaGVOb2RlKSgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLnJzYyA9IHJzYztcbiAgICAgICAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IGNhY2hlTm9kZVNlZWREYXRhWzNdO1xuICAgICAgICAgICAgICAgICgwLCBfZmlsbGxhenlpdGVtc3RpbGxsZWFmd2l0aGhlYWQuZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQpKGNhY2hlLCAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIHNlcnZlciBhY3Rpb25zIGhhdmUgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdHJlZVBhdGNoLCBjYWNoZU5vZGVTZWVkRGF0YSwgaGVhZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NlZ21lbnRjYWNoZS5yZXZhbGlkYXRlRW50aXJlQ2FjaGUpKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvblJldmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBfcmVmZXRjaGluYWN0aXZlcGFyYWxsZWxzZWdtZW50cy5yZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsOiBCb29sZWFuKG5leHRVcmwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24gJiYgcmVkaXJlY3RIcmVmKSB7XG4gICAgICAgICAgICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSAmJiAhYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBSZWRpcmVjdEJvdW5kYXJ5IHdpbGwgdHJpZ2dlciBhIG5hdmlnYXRpb24sIHdlIG5lZWQgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGVcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBGbGlnaHREYXRhIHRoYXQgd2UgZ290IGZyb20gdGhlIHNlcnZlciBhY3Rpb24gZm9yIHRoZSB0YXJnZXQgcGFnZSwgc28gdGhhdCBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYXZhaWxhYmxlIHdoZW4gdGhlIHBhZ2UgaXMgbmF2aWdhdGVkIHRvIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtZmV0Y2hlZC5cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHNlcnZlciBhY3Rpb24gZGlkbid0IHJldmFsaWRhdGUgYW55IGRhdGEsIGFzIGluIHRoYXQgY2FzZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIGFuZCB0aGUgZGF0YSB3aWxsIGJlIHJlLWZldGNoZWQgYW55d2F5LlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IGRvIHRoaXMgaW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gRHluYW1pYyBkYXRhIHNob3VsZCBuZXZlciBiZSBwbGFjZWQgaW50byB0aGUgY2FjaGUsIHVubGVzcyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gXCJjb252ZXJ0ZWRcIiB0byBzdGF0aWMgZGF0YSB1c2luZyA8TGluayBwcmVmZXRjaD17dHJ1ZX0+LiBXaGF0IHdlXG4gICAgICAgICAgICAgICAgLy8gZG8gaW5zdGVhZCBpcyByZS1wcmVmZXRjaCBsaW5rcyBhbmQgZm9ybXMgd2hlbmV2ZXIgdGhlIGNhY2hlIGlzXG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICAgICAgKDAsIF9wcmVmZXRjaGNhY2hldXRpbHMuY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KSh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byBzZXQgdGhpcyBpZiB0aGUgc2VydmVyIGFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBmdWxseSBzdGF0aWMgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFsZVRpbWU6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IGlzUHJlcmVuZGVyID8gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTCA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBzdGF0ZS5wcmVmZXRjaENhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiB0cmlnZ2VyZWQgYSByZWRpcmVjdCwgdGhlIGFjdGlvbiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gYSByZWRpcmVjdCBzbyB0aGF0IGl0J3MgaGFuZGxlZCBieSBSZWRpcmVjdEJvdW5kYXJ5IGFzIHdlIHdvbid0IGhhdmUgYSB2YWxpZFxuICAgICAgICAgICAgLy8gYWN0aW9uIHJlc3VsdCB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGguIFRoaXMgd2lsbCBlZmZlY3RpdmVseSByZXNldCB0aGUgc3RhdGUgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgdGhhdCBjYWxsZWQgdGhlIGFjdGlvbiBhcyB0aGUgZXJyb3IgYm91bmRhcnkgd2lsbCByZW1vdW50IHRoZSB0cmVlLlxuICAgICAgICAgICAgLy8gVGhlIHN0YXR1cyBjb2RlIGRvZXNuJ3QgbWF0dGVyIGhlcmUgYXMgdGhlIGFjdGlvbiBoYW5kbGVyIHdpbGwgaGF2ZSBhbHJlYWR5IHNlbnRcbiAgICAgICAgICAgIC8vIGEgcmVzcG9uc2Ugd2l0aCB0aGUgY29ycmVjdCBzdGF0dXMgY29kZS5cbiAgICAgICAgICAgIHJlamVjdCgoMCwgX3JlZGlyZWN0LmdldFJlZGlyZWN0RXJyb3IpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlZGlyZWN0SHJlZikgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZWRpcmVjdEhyZWYpIDogcmVkaXJlY3RIcmVmLCByZWRpcmVjdFR5cGUgfHwgX3JlZGlyZWN0ZXJyb3IuUmVkaXJlY3RUeXBlLnB1c2gpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9oYW5kbGVtdXRhYmxlLmhhbmRsZU11dGFibGUpKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9LCAoZSk9PntcbiAgICAgICAgLy8gV2hlbiB0aGUgc2VydmVyIGFjdGlvbiBpcyByZWplY3RlZCB3ZSBkb24ndCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBpbnN0ZWFkIGNhbGwgdGhlIHJlamVjdCBoYW5kbGVyIG9mIHRoZSBwcm9taXNlLlxuICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWFjdGlvbi1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiX2FwcGNhbGxzZXJ2ZXIiLCJyZXF1aXJlIiwiX2FwcGZpbmRzb3VyY2VtYXB1cmwiLCJfYXBwcm91dGVyaGVhZGVycyIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJfYXNzaWdubG9jYXRpb24iLCJfY3JlYXRlaHJlZmZyb211cmwiLCJfbmF2aWdhdGVyZWR1Y2VyIiwiX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZSIsIl9pc25hdmlnYXRpbmd0b25ld3Jvb3RsYXlvdXQiLCJfaGFuZGxlbXV0YWJsZSIsIl9maWxsbGF6eWl0ZW1zdGlsbGxlYWZ3aXRoaGVhZCIsIl9hcHByb3V0ZXIiLCJfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlIiwiX2hhbmRsZXNlZ21lbnRtaXNtYXRjaCIsIl9yZWZldGNoaW5hY3RpdmVwYXJhbGxlbHNlZ21lbnRzIiwiX2ZsaWdodGRhdGFoZWxwZXJzIiwiX3JlZGlyZWN0IiwiX3JlZGlyZWN0ZXJyb3IiLCJfcHJlZmV0Y2hjYWNoZXV0aWxzIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX3NlcnZlcnJlZmVyZW5jZWluZm8iLCJfc2VnbWVudGNhY2hlIiwiY3JlYXRlRnJvbUZldGNoIiwiY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IiwiZW5jb2RlUmVwbHkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwiZmV0Y2hTZXJ2ZXJBY3Rpb24iLCJzdGF0ZSIsIm5leHRVcmwiLCJwYXJhbSIsImFjdGlvbklkIiwiYWN0aW9uQXJncyIsInRlbXBvcmFyeVJlZmVyZW5jZXMiLCJpbmZvIiwiZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQiLCJ1c2VkQXJncyIsInR5cGUiLCJvbWl0VW51c2VkQXJncyIsImJvZHkiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJBY2NlcHQiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkFDVElPTl9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiTkVYVF9VUkwiLCJyZWRpcmVjdEhlYWRlciIsImxvY2F0aW9uIiwiX3JlZGlyZWN0VHlwZSIsInNwbGl0IiwicmVkaXJlY3RUeXBlIiwiUmVkaXJlY3RUeXBlIiwicHVzaCIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJpc1ByZXJlbmRlciIsIk5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiIsInJldmFsaWRhdGVkUGFydHMiLCJyZXZhbGlkYXRlZEhlYWRlciIsInBhcnNlIiwicGF0aHMiLCJ0YWciLCJjb29raWUiLCJlIiwicmVkaXJlY3RMb2NhdGlvbiIsImFzc2lnbkxvY2F0aW9uIiwiVVJMIiwiY2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsImNvbnRlbnRUeXBlIiwic3RhcnRzV2l0aCIsInJlc3BvbnNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYWxsU2VydmVyIiwiZmluZFNvdXJjZU1hcFVSTCIsImFjdGlvbkZsaWdodERhdGEiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsImFjdGlvblJlc3VsdCIsImEiLCJzdGF0dXMiLCJlcnJvciIsInRleHQiLCJFcnJvciIsImNvbmZpZ3VyYWJsZSIsImFjdGlvbiIsInJlamVjdCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidGhlbiIsImZsaWdodERhdGEiLCJyZWRpcmVjdEhyZWYiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsImhhbmRsZUV4dGVybmFsVXJsIiwiYWN0aW9uUmV2YWxpZGF0ZWQiLCJsZW5ndGgiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJyc2MiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwicHJlZmV0Y2hSc2MiLCJsb2FkaW5nIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJyZXZhbGlkYXRlRW50aXJlQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJCb29sZWFuIiwicGF0Y2hlZFRyZWUiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJ1cmwiLCJkYXRhIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsIkFVVE8iLCJnZXRSZWRpcmVjdEVycm9yIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImhhbmRsZU11dGFibGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride } } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === 'string') {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const normalizedFlightData of flightData){\n        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            '',\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n        // the entire page to reload.\n        if (newTree === null) {\n            return state;\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHFCQUFxQkMsbUJBQU9BLENBQUMsc0lBQXlCO0FBQzVELE1BQU1DLCtCQUErQkQsbUJBQU9BLENBQUMsOEpBQXFDO0FBQ2xGLE1BQU1FLCtCQUErQkYsbUJBQU9BLENBQUMsOEpBQXFDO0FBQ2xGLE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUMsc0lBQW9CO0FBQ3JELE1BQU1JLG1CQUFtQkosbUJBQU9BLENBQUMsZ0lBQXNCO0FBQ3ZELE1BQU1LLGlCQUFpQkwsbUJBQU9BLENBQUMsMEhBQW1CO0FBQ2xELE1BQU1NLGFBQWFOLG1CQUFPQSxDQUFDLHNHQUFrQjtBQUM3QyxTQUFTRixtQkFBbUJTLEtBQUssRUFBRUMsTUFBTTtJQUNyQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFQyxVQUFVLEVBQUVDLGNBQWNDLG9CQUFvQixFQUFFLEVBQUUsR0FBR0o7SUFDL0UsTUFBTUssVUFBVSxDQUFDO0lBQ2pCQSxRQUFRQywwQkFBMEIsR0FBRztJQUNyQyw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPSixlQUFlLFVBQVU7UUFDaEMsT0FBTyxDQUFDLEdBQUdQLGlCQUFpQlksaUJBQWlCLEVBQUVSLE9BQU9NLFNBQVNILFlBQVlILE1BQU1TLE9BQU8sQ0FBQ0MsV0FBVztJQUN4RztJQUNBLElBQUlDLGNBQWNYLE1BQU1ZLElBQUk7SUFDNUIsSUFBSUMsZUFBZWIsTUFBTWMsS0FBSztJQUM5QixLQUFLLE1BQU1DLHdCQUF3QlosV0FBVztRQUMxQyxNQUFNLEVBQUVhLGFBQWFDLGlCQUFpQixFQUFFTCxNQUFNTSxTQUFTLEVBQUUsR0FBR0g7UUFDNUQsTUFBTUksVUFBVSxDQUFDLEdBQUd6Qiw2QkFBNkIwQiwyQkFBMkIsRUFDNUU7WUFDSTtlQUNHSDtTQUNOLEVBQUVOLGFBQWFPLFdBQVdsQixNQUFNSSxZQUFZO1FBQzdDLGtJQUFrSTtRQUNsSSw4R0FBOEc7UUFDOUcsb0lBQW9JO1FBQ3BJLG1JQUFtSTtRQUNuSSw2QkFBNkI7UUFDN0IsSUFBSWUsWUFBWSxNQUFNO1lBQ2xCLE9BQU9uQjtRQUNYO1FBQ0EsSUFBSSxDQUFDLEdBQUdMLDZCQUE2QjBCLDJCQUEyQixFQUFFVixhQUFhUSxVQUFVO1lBQ3JGLE9BQU8sQ0FBQyxHQUFHdkIsaUJBQWlCWSxpQkFBaUIsRUFBRVIsT0FBT00sU0FBU04sTUFBTUksWUFBWSxFQUFFSixNQUFNUyxPQUFPLENBQUNDLFdBQVc7UUFDaEg7UUFDQSxNQUFNWSwyQkFBMkJqQix1QkFBdUIsQ0FBQyxHQUFHYixtQkFBbUIrQixpQkFBaUIsRUFBRWxCLHdCQUF3Qm1CO1FBQzFILElBQUlGLDBCQUEwQjtZQUMxQmhCLFFBQVFGLFlBQVksR0FBR2tCO1FBQzNCO1FBQ0EsTUFBTVIsUUFBUSxDQUFDLEdBQUdmLFdBQVcwQixvQkFBb0I7UUFDaEQsSUFBRzVCLGlCQUFpQjZCLGVBQWUsRUFBRWIsY0FBY0MsT0FBT0M7UUFDM0RULFFBQVFxQixXQUFXLEdBQUdSO1FBQ3RCYixRQUFRUSxLQUFLLEdBQUdBO1FBQ2hCRCxlQUFlQztRQUNmSCxjQUFjUTtJQUNsQjtJQUNBLE9BQU8sQ0FBQyxHQUFHckIsZUFBZThCLGFBQWEsRUFBRTVCLE9BQU9NO0FBQ3BEO0FBRUEsSUFBSSxDQUFDLE9BQU9uQixRQUFRMEMsT0FBTyxLQUFLLGNBQWUsT0FBTzFDLFFBQVEwQyxPQUFPLEtBQUssWUFBWTFDLFFBQVEwQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8xQyxRQUFRMEMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzdDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTBDLE9BQU8sRUFBRSxjQUFjO1FBQUV6QyxPQUFPO0lBQUs7SUFDbkVILE9BQU84QyxNQUFNLENBQUM1QyxRQUFRMEMsT0FBTyxFQUFFMUM7SUFDL0I2QyxPQUFPN0MsT0FBTyxHQUFHQSxRQUFRMEMsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VydmVyUGF0Y2hSZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJQYXRjaFJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfY3JlYXRlaHJlZmZyb211cmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5jb25zdCBfYXBwbHlyb3V0ZXJzdGF0ZXBhdGNodG90cmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xuY29uc3QgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbmNvbnN0IF9uYXZpZ2F0ZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuY29uc3QgX2FwcGx5ZmxpZ2h0ZGF0YSA9IHJlcXVpcmUoXCIuLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9oYW5kbGVtdXRhYmxlID0gcmVxdWlyZShcIi4uL2hhbmRsZS1tdXRhYmxlXCIpO1xuY29uc3QgX2FwcHJvdXRlciA9IHJlcXVpcmUoXCIuLi8uLi9hcHAtcm91dGVyXCIpO1xuZnVuY3Rpb24gc2VydmVyUGF0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHNlcnZlclJlc3BvbnNlOiB7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG11dGFibGUgPSB7fTtcbiAgICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZXJlZHVjZXIuaGFuZGxlRXh0ZXJuYWxVcmwpKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZTtcbiAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGU7XG4gICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKXtcbiAgICAgICAgY29uc3QgeyBzZWdtZW50UGF0aDogZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWU6IHRyZWVQYXRjaCB9ID0gbm9ybWFsaXplZEZsaWdodERhdGE7XG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSAoMCwgX2FwcGx5cm91dGVyc3RhdGVwYXRjaHRvdHJlZS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICBdLCBjdXJyZW50VHJlZSwgdHJlZVBhdGNoLCBzdGF0ZS5jYW5vbmljYWxVcmwpO1xuICAgICAgICAvLyBgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlYCByZXR1cm5zIGBudWxsYCB3aGVuIGl0IGRldGVybWluZWQgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSBjdXJyZW50IHRyZWUuXG4gICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgdHJlZSB0aGF0IGRvZXNuJ3QgbWF0Y2ggd2hhdCB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2VydmVyIHBhdGNoIGFjdGlvbiB0b29rIGxvbmdlciB0byByZXNvbHZlIHRoYW4gYSBzdWJzZXF1ZW50IG5hdmlnYXRpb24gd2hpY2ggd291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB0cmVlLlxuICAgICAgICAvLyBQcmV2aW91c2x5IHRoaXMgY2FzZSB0cmlnZ2VyZWQgYW4gTVBBIG5hdmlnYXRpb24gYnV0IGl0IHNob3VsZCBiZSBzYWZlIHRvIHNpbXBseSBkaXNjYXJkIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgcmF0aGVyIHRoYW4gZm9yY2luZ1xuICAgICAgICAvLyB0aGUgZW50aXJlIHBhZ2UgdG8gcmVsb2FkLlxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX2lzbmF2aWdhdGluZ3RvbmV3cm9vdGxheW91dC5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpKGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVyZWR1Y2VyLmhhbmRsZUV4dGVybmFsVXJsKShzdGF0ZSwgbXV0YWJsZSwgc3RhdGUuY2Fub25pY2FsVXJsLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/ICgwLCBfY3JlYXRlaHJlZmZyb211cmwuY3JlYXRlSHJlZkZyb21VcmwpKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZikge1xuICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGUgPSAoMCwgX2FwcHJvdXRlci5jcmVhdGVFbXB0eUNhY2hlTm9kZSkoKTtcbiAgICAgICAgKDAsIF9hcHBseWZsaWdodGRhdGEuYXBwbHlGbGlnaHREYXRhKShjdXJyZW50Q2FjaGUsIGNhY2hlLCBub3JtYWxpemVkRmxpZ2h0RGF0YSk7XG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWU7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2hhbmRsZW11dGFibGUuaGFuZGxlTXV0YWJsZSkoc3RhdGUsIG11dGFibGUpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiX2NyZWF0ZWhyZWZmcm9tdXJsIiwicmVxdWlyZSIsIl9hcHBseXJvdXRlcnN0YXRlcGF0Y2h0b3RyZWUiLCJfaXNuYXZpZ2F0aW5ndG9uZXdyb290bGF5b3V0IiwiX25hdmlnYXRlcmVkdWNlciIsIl9hcHBseWZsaWdodGRhdGEiLCJfaGFuZGxlbXV0YWJsZSIsIl9hcHByb3V0ZXIiLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybCIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwic2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {\n            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n            flightRouterState: [\n                rootTree[0],\n                rootTree[1],\n                rootTree[2],\n                'refetch'\n            ],\n            nextUrl: includeNextUrl ? state.nextUrl : null\n        }).then((param)=>{\n            let { flightData } = param;\n            if (typeof flightData !== 'string') {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n        tree[2] = path;\n        tree[3] = 'refresh';\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsMENBQTBDO1FBQ3RDLE9BQU9BO0lBQ1g7SUFDQUMsaUNBQWlDO1FBQzdCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLG1CQUFtQkMsbUJBQU9BLENBQUMsK0hBQXFCO0FBQ3RELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsdUlBQXlCO0FBQzlELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHVHQUE2QjtBQUN0RCxlQUFlUixnQ0FBZ0NXLE9BQU87SUFDbEQsTUFBTUMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1DLG9DQUFvQztRQUN0QyxHQUFHSCxPQUFPO1FBQ1ZJLFVBQVVKLFFBQVFLLFdBQVc7UUFDN0JKO0lBQ0o7QUFDSjtBQUNBLGVBQWVFLG9DQUFvQ0csS0FBSztJQUNwRCxJQUFJLEVBQUVDLEtBQUssRUFBRUYsV0FBVyxFQUFFRyxZQUFZLEVBQUVDLGNBQWMsRUFBRVIsZUFBZSxFQUFFRyxXQUFXQyxXQUFXLEVBQUVLLFlBQVksRUFBRSxHQUFHSjtJQUNsSCxNQUFNLEdBQUdLLGdCQUFnQkMsYUFBYUMsY0FBYyxHQUFHUjtJQUN2RCxNQUFNUyxnQkFBZ0IsRUFBRTtJQUN4QixJQUFJRixlQUFlQSxnQkFBZ0JGLGdCQUFnQkcsa0JBQWtCLGFBQWEsNEZBQTRGO0lBQzlLLHNEQUFzRDtJQUN0RCxDQUFDWixnQkFBZ0JjLEdBQUcsQ0FBQ0gsY0FBYztRQUMvQlgsZ0JBQWdCZSxHQUFHLENBQUNKLGFBQWEsMkJBQTJCOztRQUU1RCx3SEFBd0g7UUFDeEgsa0lBQWtJO1FBQ2xJLE1BQU1LLGVBQWUsQ0FBQyxHQUFHbkIscUJBQXFCb0IsbUJBQW1CLEVBQUUsSUFBSUMsSUFBSVAsYUFBYVEsU0FBU0MsTUFBTSxHQUFHO1lBQ3RHLGdHQUFnRztZQUNoRyw4SEFBOEg7WUFDOUhDLG1CQUFtQjtnQkFDZmxCLFFBQVEsQ0FBQyxFQUFFO2dCQUNYQSxRQUFRLENBQUMsRUFBRTtnQkFDWEEsUUFBUSxDQUFDLEVBQUU7Z0JBQ1g7YUFDSDtZQUNEbUIsU0FBU2QsaUJBQWlCRixNQUFNZ0IsT0FBTyxHQUFHO1FBQzlDLEdBQUdDLElBQUksQ0FBQyxDQUFDbEI7WUFDTCxJQUFJLEVBQUVtQixVQUFVLEVBQUUsR0FBR25CO1lBQ3JCLElBQUksT0FBT21CLGVBQWUsVUFBVTtnQkFDaEMsS0FBSyxNQUFNQyxrQkFBa0JELFdBQVc7b0JBQ3BDLHdGQUF3RjtvQkFDeEYsNEdBQTRHO29CQUM1Ryw0RUFBNEU7b0JBQzNFLElBQUc3QixpQkFBaUIrQixlQUFlLEVBQUVuQixjQUFjQSxjQUFja0I7Z0JBQ3RFO1lBQ0osT0FBTztZQUNQLDRHQUE0RztZQUM1RywrR0FBK0c7WUFDL0csc0VBQXNFO1lBQ3RFO1FBQ0o7UUFDQVosY0FBY2MsSUFBSSxDQUFDWDtJQUN2QjtJQUNBLElBQUksTUFBTVksT0FBT2xCLGVBQWU7UUFDNUIsTUFBTW1CLHVCQUF1QjNCLG9DQUFvQztZQUM3REk7WUFDQUYsYUFBYU0sY0FBYyxDQUFDa0IsSUFBSTtZQUNoQ3JCO1lBQ0FDO1lBQ0FSO1lBQ0FHO1lBQ0FNO1FBQ0o7UUFDQUksY0FBY2MsSUFBSSxDQUFDRTtJQUN2QjtJQUNBLE1BQU1DLFFBQVF2QyxHQUFHLENBQUNzQjtBQUN0QjtBQUNBLFNBQVMxQix5Q0FBeUM0QyxJQUFJLEVBQUVDLElBQUk7SUFDeEQsTUFBTSxDQUFDQyxTQUFTdkIsa0JBQWtCRSxjQUFjLEdBQUdtQjtJQUNuRCxvR0FBb0c7SUFDcEcsSUFBSUUsUUFBUUMsUUFBUSxDQUFDcEMsU0FBU3FDLGdCQUFnQixLQUFLdkIsa0JBQWtCLFdBQVc7UUFDNUVtQixJQUFJLENBQUMsRUFBRSxHQUFHQztRQUNWRCxJQUFJLENBQUMsRUFBRSxHQUFHO0lBQ2Q7SUFDQSxJQUFJLE1BQU1ILE9BQU9sQixlQUFlO1FBQzVCdkIseUNBQXlDdUIsY0FBYyxDQUFDa0IsSUFBSSxFQUFFSTtJQUNsRTtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9oRCxRQUFRb0QsT0FBTyxLQUFLLGNBQWUsT0FBT3BELFFBQVFvRCxPQUFPLEtBQUssWUFBWXBELFFBQVFvRCxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9wRCxRQUFRb0QsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3ZELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW9ELE9BQU8sRUFBRSxjQUFjO1FBQUVuRCxPQUFPO0lBQUs7SUFDbkVILE9BQU93RCxNQUFNLENBQUN0RCxRQUFRb0QsT0FBTyxFQUFFcEQ7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUW9ELE9BQU87QUFDbEMsRUFFQSw4REFBOEQiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50czogbnVsbCxcbiAgICByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9LFxuICAgIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cztcbiAgICB9XG59KTtcbmNvbnN0IF9hcHBseWZsaWdodGRhdGEgPSByZXF1aXJlKFwiLi9hcHBseS1mbGlnaHQtZGF0YVwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyhvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlZFNlZ21lbnRzID0gbmV3IFNldCgpO1xuICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcm9vdFRyZWU6IG9wdGlvbnMudXBkYXRlZFRyZWUsXG4gICAgICAgIGZldGNoZWRTZWdtZW50c1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwocGFyYW0pIHtcbiAgICBsZXQgeyBzdGF0ZSwgdXBkYXRlZFRyZWUsIHVwZGF0ZWRDYWNoZSwgaW5jbHVkZU5leHRVcmwsIGZldGNoZWRTZWdtZW50cywgcm9vdFRyZWUgPSB1cGRhdGVkVHJlZSwgY2Fub25pY2FsVXJsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBbLCBwYXJhbGxlbFJvdXRlcywgcmVmZXRjaFBhdGgsIHJlZmV0Y2hNYXJrZXJdID0gdXBkYXRlZFRyZWU7XG4gICAgY29uc3QgZmV0Y2hQcm9taXNlcyA9IFtdO1xuICAgIGlmIChyZWZldGNoUGF0aCAmJiByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmIHJlZmV0Y2hNYXJrZXIgPT09ICdyZWZyZXNoJyAmJiAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgdHJlZSB0byBjb250YWluIG11bHRpcGxlIHNlZ21lbnRzIHRoYXQgY29udGFpbiBkYXRhIGF0IHRoZSBzYW1lIFVSTFxuICAgIC8vIHdlIGtlZXAgdHJhY2sgb2YgdGhlbSBzbyB3ZSBjYW4gZGVkdXBlIHRoZSByZXF1ZXN0c1xuICAgICFmZXRjaGVkU2VnbWVudHMuaGFzKHJlZmV0Y2hQYXRoKSkge1xuICAgICAgICBmZXRjaGVkU2VnbWVudHMuYWRkKHJlZmV0Y2hQYXRoKSAvLyBNYXJrIHRoaXMgVVJMIGFzIGZldGNoZWRcbiAgICAgICAgO1xuICAgICAgICAvLyBFYWdlcmx5IGtpY2sgb2ZmIHRoZSBmZXRjaCBmb3IgdGhlIHJlZmV0Y2ggcGF0aCAmIHRoZSBwYXJhbGxlbCByb3V0ZXMuIFRoaXMgc2hvdWxkIGJlIGZpbmUgdG8gZG8gYXMgdGhleSBlYWNoIG9wZXJhdGVcbiAgICAgICAgLy8gaW5kZXBlbmRlbnRseSBvbiB0aGVpciBvd24gY2FjaGUgbm9kZXMsIGFuZCBgYXBwbHlGbGlnaHREYXRhYCB3aWxsIGNvcHkgYW55dGhpbmcgaXQgZG9lc24ndCBjYXJlIGFib3V0IGZyb20gdGhlIGV4aXN0aW5nIGNhY2hlLlxuICAgICAgICBjb25zdCBmZXRjaFByb21pc2UgPSAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkobmV3IFVSTChyZWZldGNoUGF0aCwgbG9jYXRpb24ub3JpZ2luKSwge1xuICAgICAgICAgICAgLy8gcmVmZXRjaCBmcm9tIHRoZSByb290IG9mIHRoZSB1cGRhdGVkIHRyZWUsIG90aGVyd2lzZSBpdCB3aWxsIGJlIHNjb3BlZCB0byB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICAgICAgICAvLyBhbmQgbWlnaHQgbm90IGNvbnRhaW4gdGhlIGRhdGEgd2UgbmVlZCB0byBwYXRjaCBpbiBpbnRlcmNlcHRpb24gcm91dGUgZGF0YSAoc3VjaCBhcyBkeW5hbWljIHBhcmFtcyBmcm9tIGEgcHJldmlvdXMgc2VnbWVudClcbiAgICAgICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBbXG4gICAgICAgICAgICAgICAgcm9vdFRyZWVbMF0sXG4gICAgICAgICAgICAgICAgcm9vdFRyZWVbMV0sXG4gICAgICAgICAgICAgICAgcm9vdFRyZWVbMl0sXG4gICAgICAgICAgICAgICAgJ3JlZmV0Y2gnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbFxuICAgICAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IGZsaWdodERhdGEgfSA9IHBhcmFtO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgcGFzcyB0aGUgbmV3IGNhY2hlIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGNsZWFyaW5nIHRoZSByb3V0ZXIgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGZpbGxpbmcgaW4gdGhlIG5ldyBwYWdlIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBNZWFuaW5nIHRoZSBleGlzdGluZyBjYWNoZSBpcyBhY3R1YWxseSB0aGUgY2FjaGUgdGhhdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgICAgICAgICAgICAoMCwgX2FwcGx5ZmxpZ2h0ZGF0YS5hcHBseUZsaWdodERhdGEpKHVwZGF0ZWRDYWNoZSwgdXBkYXRlZENhY2hlLCBmbGlnaHREYXRhUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAgICAgLy8gSSdtIG5vdCAxMDAlIHN1cmUgb2YgdGhpcyBkZWNpc2lvbiwgYnV0IGl0IHNlZW1zIHVubGlrZWx5IHRoYXQgd2UnZCB3YW50IHRvIGludHJvZHVjZSBhIHJlZGlyZWN0IHNpZGUgZWZmZWN0XG4gICAgICAgICAgICAvLyB3aGVuIHJlZnJlc2hpbmcgb24tc2NyZWVuIGRhdGEsIHNvIGhhbmRsaW5nIHRoaXMgaGFzIGJlZW4gb21taXR0ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsRmV0Y2hQcm9taXNlID0gcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVkVHJlZTogcGFyYWxsZWxSb3V0ZXNba2V5XSxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgICAgICAgZmV0Y2hlZFNlZ21lbnRzLFxuICAgICAgICAgICAgcm9vdFRyZWUsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGZldGNoUHJvbWlzZXMucHVzaChwYXJhbGxlbEZldGNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGZldGNoUHJvbWlzZXMpO1xufVxuZnVuY3Rpb24gYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyh0cmVlLCBwYXRoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZTtcbiAgICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gICAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoX3NlZ21lbnQuUEFHRV9TRUdNRU5UX0tFWSkgJiYgcmVmZXRjaE1hcmtlciAhPT0gJ3JlZnJlc2gnKSB7XG4gICAgICAgIHRyZWVbMl0gPSBwYXRoO1xuICAgICAgICB0cmVlWzNdID0gJ3JlZnJlc2gnO1xuICAgIH1cbiAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyhwYXJhbGxlbFJvdXRlc1trZXldLCBwYXRoKTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfYXBwbHlmbGlnaHRkYXRhIiwicmVxdWlyZSIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwiX3NlZ21lbnQiLCJvcHRpb25zIiwiZmV0Y2hlZFNlZ21lbnRzIiwiU2V0IiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50c0ltcGwiLCJyb290VHJlZSIsInVwZGF0ZWRUcmVlIiwicGFyYW0iLCJzdGF0ZSIsInVwZGF0ZWRDYWNoZSIsImluY2x1ZGVOZXh0VXJsIiwiY2Fub25pY2FsVXJsIiwicGFyYWxsZWxSb3V0ZXMiLCJyZWZldGNoUGF0aCIsInJlZmV0Y2hNYXJrZXIiLCJmZXRjaFByb21pc2VzIiwiaGFzIiwiYWRkIiwiZmV0Y2hQcm9taXNlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwidGhlbiIsImZsaWdodERhdGEiLCJmbGlnaHREYXRhUGF0aCIsImFwcGx5RmxpZ2h0RGF0YSIsInB1c2giLCJrZXkiLCJwYXJhbGxlbEZldGNoUHJvbWlzZSIsIlByb21pc2UiLCJ0cmVlIiwicGF0aCIsInNlZ21lbnQiLCJpbmNsdWRlcyIsIlBBR0VfU0VHTUVOVF9LRVkiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_PREFETCH = 'prefetch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\nvar PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n    return PrefetchCacheEntryStatus;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FVTjtBQUNBLFNBQVNVLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUloQixPQUFPQyxjQUFjLENBQUNjLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVosU0FBUztJQUNiRyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGlCQUFpQjtRQUNiLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPQTtJQUNYO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFPQTtJQUNYO0lBQ0FDLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0lBQ0FDLDBCQUEwQjtRQUN0QixPQUFPQTtJQUNYO0lBQ0FDLGNBQWM7UUFDVixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTCxpQkFBaUI7QUFDdkIsTUFBTUYsa0JBQWtCO0FBQ3hCLE1BQU1HLGlCQUFpQjtBQUN2QixNQUFNRSxzQkFBc0I7QUFDNUIsTUFBTUosa0JBQWtCO0FBQ3hCLE1BQU1GLHFCQUFxQjtBQUMzQixNQUFNSyx1QkFBdUI7QUFDN0IsSUFBSUcsZUFBZSxXQUFXLEdBQUcsU0FBU0EsWUFBWTtJQUNsREEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLFlBQVksR0FBRztJQUM1QixPQUFPQTtBQUNYLEVBQUUsQ0FBQztBQUNILElBQUlELDJCQUEyQixXQUFXLEdBQUcsU0FBU0Esd0JBQXdCO0lBQzFFQSx3QkFBd0IsQ0FBQyxRQUFRLEdBQUc7SUFDcENBLHdCQUF3QixDQUFDLFdBQVcsR0FBRztJQUN2Q0Esd0JBQXdCLENBQUMsVUFBVSxHQUFHO0lBQ3RDQSx3QkFBd0IsQ0FBQyxRQUFRLEdBQUc7SUFDcEMsT0FBT0E7QUFDWCxFQUFFLENBQUM7QUFFSCxJQUFJLENBQUMsT0FBT1YsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTztJQUFLO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQ1RJT05fSE1SX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX05BVklHQVRFOiBudWxsLFxuICAgIEFDVElPTl9QUkVGRVRDSDogbnVsbCxcbiAgICBBQ1RJT05fUkVGUkVTSDogbnVsbCxcbiAgICBBQ1RJT05fUkVTVE9SRTogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX0FDVElPTjogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBudWxsLFxuICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1czogbnVsbCxcbiAgICBQcmVmZXRjaEtpbmQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgQUNUSU9OX0hNUl9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9ITVJfUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9OQVZJR0FURTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fTkFWSUdBVEU7XG4gICAgfSxcbiAgICBBQ1RJT05fUFJFRkVUQ0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1BSRUZFVENIO1xuICAgIH0sXG4gICAgQUNUSU9OX1JFRlJFU0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1JFRlJFU0g7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVTVE9SRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVTVE9SRTtcbiAgICB9LFxuICAgIEFDVElPTl9TRVJWRVJfQUNUSU9OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9TRVJWRVJfQUNUSU9OO1xuICAgIH0sXG4gICAgQUNUSU9OX1NFUlZFUl9QQVRDSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX1BBVENIO1xuICAgIH0sXG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cztcbiAgICB9LFxuICAgIFByZWZldGNoS2luZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcmVmZXRjaEtpbmQ7XG4gICAgfVxufSk7XG5jb25zdCBBQ1RJT05fUkVGUkVTSCA9ICdyZWZyZXNoJztcbmNvbnN0IEFDVElPTl9OQVZJR0FURSA9ICduYXZpZ2F0ZSc7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9ICdyZXN0b3JlJztcbmNvbnN0IEFDVElPTl9TRVJWRVJfUEFUQ0ggPSAnc2VydmVyLXBhdGNoJztcbmNvbnN0IEFDVElPTl9QUkVGRVRDSCA9ICdwcmVmZXRjaCc7XG5jb25zdCBBQ1RJT05fSE1SX1JFRlJFU0ggPSAnaG1yLXJlZnJlc2gnO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9BQ1RJT04gPSAnc2VydmVyLWFjdGlvbic7XG52YXIgUHJlZmV0Y2hLaW5kID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihQcmVmZXRjaEtpbmQpIHtcbiAgICBQcmVmZXRjaEtpbmRbXCJBVVRPXCJdID0gXCJhdXRvXCI7XG4gICAgUHJlZmV0Y2hLaW5kW1wiRlVMTFwiXSA9IFwiZnVsbFwiO1xuICAgIFByZWZldGNoS2luZFtcIlRFTVBPUkFSWVwiXSA9IFwidGVtcG9yYXJ5XCI7XG4gICAgcmV0dXJuIFByZWZldGNoS2luZDtcbn0oe30pO1xudmFyIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzKSB7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wiZnJlc2hcIl0gPSBcImZyZXNoXCI7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wicmV1c2FibGVcIl0gPSBcInJldXNhYmxlXCI7XG4gICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzW1wiZXhwaXJlZFwiXSA9IFwiZXhwaXJlZFwiO1xuICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1c1tcInN0YWxlXCJdID0gXCJzdGFsZVwiO1xuICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXM7XG59KHt9KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXItdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiQUNUSU9OX0hNUl9SRUZSRVNIIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsIlByZWZldGNoS2luZCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"reducer\", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _hmrrefreshreducer = __webpack_require__(/*! ./reducers/hmr-refresh-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error('Unknown action'), \"__NEXT_ERROR_CODE\", {\n                value: \"E295\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHNCQUFzQkMsbUJBQU9BLENBQUMscUlBQXdCO0FBQzVELE1BQU1DLG1CQUFtQkQsbUJBQU9BLENBQUMsK0lBQTZCO0FBQzlELE1BQU1FLHNCQUFzQkYsbUJBQU9BLENBQUMsdUpBQWlDO0FBQ3JFLE1BQU1HLGtCQUFrQkgsbUJBQU9BLENBQUMsNklBQTRCO0FBQzVELE1BQU1JLGtCQUFrQkosbUJBQU9BLENBQUMsNklBQTRCO0FBQzVELE1BQU1LLG1CQUFtQkwsbUJBQU9BLENBQUMsK0lBQTZCO0FBQzlELE1BQU1NLHFCQUFxQk4sbUJBQU9BLENBQUMscUpBQWdDO0FBQ25FLE1BQU1PLHVCQUF1QlAsbUJBQU9BLENBQUMseUpBQWtDO0FBQ3ZFOztDQUVDLEdBQUcsU0FBU1EsY0FBY0MsS0FBSyxFQUFFQyxNQUFNO0lBQ3BDLE9BQU9BLE9BQU9DLElBQUk7UUFDZCxLQUFLWixvQkFBb0JhLGVBQWU7WUFDcEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdYLGlCQUFpQlksZUFBZSxFQUFFSixPQUFPQztZQUN4RDtRQUNKLEtBQUtYLG9CQUFvQmUsbUJBQW1CO1lBQ3hDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHWixvQkFBb0JhLGtCQUFrQixFQUFFTixPQUFPQztZQUM5RDtRQUNKLEtBQUtYLG9CQUFvQmlCLGNBQWM7WUFDbkM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdiLGdCQUFnQmMsY0FBYyxFQUFFUixPQUFPQztZQUN0RDtRQUNKLEtBQUtYLG9CQUFvQm1CLGNBQWM7WUFDbkM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdkLGdCQUFnQmUsY0FBYyxFQUFFVixPQUFPQztZQUN0RDtRQUNKLEtBQUtYLG9CQUFvQnFCLGtCQUFrQjtZQUN2QztnQkFDSSxPQUFPLENBQUMsR0FBR2QsbUJBQW1CZSxpQkFBaUIsRUFBRVosT0FBT0M7WUFDNUQ7UUFDSixLQUFLWCxvQkFBb0J1QixlQUFlO1lBQ3BDO2dCQUNJLE9BQU8sQ0FBQyxHQUFHakIsaUJBQWlCa0IsZUFBZSxFQUFFZCxPQUFPQztZQUN4RDtRQUNKLEtBQUtYLG9CQUFvQnlCLG9CQUFvQjtZQUN6QztnQkFDSSxPQUFPLENBQUMsR0FBR2pCLHFCQUFxQmtCLG1CQUFtQixFQUFFaEIsT0FBT0M7WUFDaEU7UUFDSiwrREFBK0Q7UUFDL0Q7WUFDSSxNQUFNbEIsT0FBT0MsY0FBYyxDQUFDLElBQUlpQyxNQUFNLG1CQUFtQixxQkFBcUI7Z0JBQzFFL0IsT0FBTztnQkFDUEMsWUFBWTtnQkFDWitCLGNBQWM7WUFDbEI7SUFDUjtBQUNKO0FBQ0EsU0FBU0MsY0FBY25CLEtBQUssRUFBRW9CLE9BQU87SUFDakMsT0FBT3BCO0FBQ1g7QUFDQSxNQUFNWCxVQUFVLE1BQTZCLEdBQUc4QixDQUFhQSxHQUFHcEI7QUFFaEUsSUFBSSxDQUFDLE9BQU9kLFFBQVFvQyxPQUFPLEtBQUssY0FBZSxPQUFPcEMsUUFBUW9DLE9BQU8sS0FBSyxZQUFZcEMsUUFBUW9DLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BDLFFBQVFvQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0MsT0FBTyxFQUFFLGNBQWM7UUFBRW5DLE9BQU87SUFBSztJQUNuRUgsT0FBT3dDLE1BQU0sQ0FBQ3RDLFFBQVFvQyxPQUFPLEVBQUVwQztJQUMvQnVDLE9BQU92QyxPQUFPLEdBQUdBLFFBQVFvQyxPQUFPO0FBQ2xDLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWR1Y2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2VyO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgX25hdmlnYXRlcmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXJcIik7XG5jb25zdCBfc2VydmVycGF0Y2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXJcIik7XG5jb25zdCBfcmVzdG9yZXJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXJcIik7XG5jb25zdCBfcmVmcmVzaHJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9yZWZyZXNoLXJlZHVjZXJcIik7XG5jb25zdCBfcHJlZmV0Y2hyZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlclwiKTtcbmNvbnN0IF9obXJyZWZyZXNocmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL2htci1yZWZyZXNoLXJlZHVjZXJcIik7XG5jb25zdCBfc2VydmVyYWN0aW9ucmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlclwiKTtcbi8qKlxuICogUmVkdWNlciB0aGF0IGhhbmRsZXMgdGhlIGFwcC1yb3V0ZXIgc3RhdGUgdXBkYXRlcy5cbiAqLyBmdW5jdGlvbiBjbGllbnRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpe1xuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlcmVkdWNlci5uYXZpZ2F0ZVJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJyZWR1Y2VydHlwZXMuQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zZXJ2ZXJwYXRjaHJlZHVjZXIuc2VydmVyUGF0Y2hSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9SRVNUT1JFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3RvcmVyZWR1Y2VyLnJlc3RvcmVSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZnJlc2hyZWR1Y2VyLnJlZnJlc2hSZWR1Y2VyKShzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVycmVkdWNlcnR5cGVzLkFDVElPTl9ITVJfUkVGUkVTSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9obXJyZWZyZXNocmVkdWNlci5obXJSZWZyZXNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fUFJFRkVUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcHJlZmV0Y2hyZWR1Y2VyLnByZWZldGNoUmVkdWNlcikoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlcnJlZHVjZXJ0eXBlcy5BQ1RJT05fU0VSVkVSX0FDVElPTjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zZXJ2ZXJhY3Rpb25yZWR1Y2VyLnNlcnZlckFjdGlvblJlZHVjZXIpKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ1Vua25vd24gYWN0aW9uJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUyOTVcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCByZWR1Y2VyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInJlZHVjZXIiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicmVxdWlyZSIsIl9uYXZpZ2F0ZXJlZHVjZXIiLCJfc2VydmVycGF0Y2hyZWR1Y2VyIiwiX3Jlc3RvcmVyZWR1Y2VyIiwiX3JlZnJlc2hyZWR1Y2VyIiwiX3ByZWZldGNocmVkdWNlciIsIl9obXJyZWZyZXNocmVkdWNlciIsIl9zZXJ2ZXJhY3Rpb25yZWR1Y2VyIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIkFDVElPTl9OQVZJR0FURSIsIm5hdmlnYXRlUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJBQ1RJT05fUkVTVE9SRSIsInJlc3RvcmVSZWR1Y2VyIiwiQUNUSU9OX1JFRlJFU0giLCJyZWZyZXNoUmVkdWNlciIsIkFDVElPTl9ITVJfUkVGUkVTSCIsImhtclJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicHJlZmV0Y2hSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiRXJyb3IiLCJjb25maWd1cmFibGUiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setCacheBustingSearchParam\", ({\n    enumerable: true,\n    get: function() {\n        return setCacheBustingSearchParam;\n    }\n}));\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hash.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(','));\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    const pairs = rawQuery.split('&').filter(Boolean);\n    pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + \"=\" + uniqueCacheKey);\n    url.search = pairs.length ? \"?\" + pairs.join('&') : '';\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-cache-busting-search-param.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLmpzIiwibWFwcGluZ3MiOiJxREFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsOERBQTZEO0lBQ3pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsaUdBQTBCO0FBQ2hELE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUMsbUhBQXVCO0FBQ3pELE1BQU1GLDZCQUE2QixDQUFDSSxLQUFLQztJQUNyQyxNQUFNQyxpQkFBaUIsQ0FBQyxHQUFHTCxNQUFNTSxPQUFPLEVBQUU7UUFDdENGLE9BQU8sQ0FBQ0Ysa0JBQWtCSywyQkFBMkIsQ0FBQyxJQUFJO1FBQzFESCxPQUFPLENBQUNGLGtCQUFrQk0sbUNBQW1DLENBQUMsSUFBSTtRQUNsRUosT0FBTyxDQUFDRixrQkFBa0JPLDZCQUE2QixDQUFDO1FBQ3hETCxPQUFPLENBQUNGLGtCQUFrQlEsUUFBUSxDQUFDO0tBQ3RDLENBQUNDLElBQUksQ0FBQztJQUNQOzs7Ozs7Ozs7O0dBVUQsR0FBRyxNQUFNQyxpQkFBaUJULElBQUlVLE1BQU07SUFDbkMsTUFBTUMsV0FBV0YsZUFBZUcsVUFBVSxDQUFDLE9BQU9ILGVBQWVJLEtBQUssQ0FBQyxLQUFLSjtJQUM1RSxNQUFNSyxRQUFRSCxTQUFTSSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQztJQUN6Q0gsTUFBTUksSUFBSSxDQUFDbkIsa0JBQWtCb0Isb0JBQW9CLEdBQUcsTUFBTWpCO0lBQzFERixJQUFJVSxNQUFNLEdBQUdJLE1BQU1NLE1BQU0sR0FBRyxNQUFNTixNQUFNTixJQUFJLENBQUMsT0FBTztBQUN4RDtBQUVBLElBQUksQ0FBQyxPQUFPaEIsUUFBUTZCLE9BQU8sS0FBSyxjQUFlLE9BQU83QixRQUFRNkIsT0FBTyxLQUFLLFlBQVk3QixRQUFRNkIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPN0IsUUFBUTZCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktoQyxPQUFPQyxjQUFjLENBQUNDLFFBQVE2QixPQUFPLEVBQUUsY0FBYztRQUFFNUIsT0FBTztJQUFLO0lBQ25FSCxPQUFPaUMsTUFBTSxDQUFDL0IsUUFBUTZCLE9BQU8sRUFBRTdCO0lBQy9CZ0MsT0FBT2hDLE9BQU8sR0FBR0EsUUFBUTZCLE9BQU87QUFDbEMsRUFFQSwwREFBMEQiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW07XG4gICAgfVxufSk7XG5jb25zdCBfaGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2hhc2hcIik7XG5jb25zdCBfYXBwcm91dGVyaGVhZGVycyA9IHJlcXVpcmUoXCIuLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5jb25zdCBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSA9ICh1cmwsIGhlYWRlcnMpPT57XG4gICAgY29uc3QgdW5pcXVlQ2FjaGVLZXkgPSAoMCwgX2hhc2guaGV4SGFzaCkoW1xuICAgICAgICBoZWFkZXJzW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gfHwgJzAnLFxuICAgICAgICBoZWFkZXJzW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXSB8fCAnMCcsXG4gICAgICAgIGhlYWRlcnNbX2FwcHJvdXRlcmhlYWRlcnMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdLFxuICAgICAgICBoZWFkZXJzW19hcHByb3V0ZXJoZWFkZXJzLk5FWFRfVVJMXVxuICAgIF0uam9pbignLCcpKTtcbiAgICAvKipcbiAgICogTm90ZSB0aGF0IHdlIGludGVudGlvbmFsbHkgZG8gbm90IHVzZSBgdXJsLnNlYXJjaFBhcmFtcy5zZXRgIGhlcmU6XG4gICAqXG4gICAqIGNvbnN0IHVybCA9IG5ldyBVUkwoJ2h0dHBzOi8vZXhhbXBsZS5jb20vc2VhcmNoP3E9Y3VzdG9tJTIwc3BhY2luZycpO1xuICAgKiB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX3JzYycsICdhYmMxMjMnKTtcbiAgICogY29uc29sZS5sb2codXJsLnRvU3RyaW5nKCkpOyAvLyBPdXRwdXRzOiBodHRwczovL2V4YW1wbGUuY29tL3NlYXJjaD9xPWN1c3RvbStzcGFjaW5nJl9yc2M9YWJjMTIzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIDwtLS0gdGhpcyBpcyBjYXVzaW5nIGNvbmZ1c2lvblxuICAgKiBUaGlzIGlzIGluIGZhY3QgaW50ZW5kZWQgYmFzZWQgb24gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zLCBidXRcbiAgICogd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgJTIwIGFzICUyMCBpZiB0aGF0J3Mgd2hhdCB0aGUgdXNlciBwYXNzZWQgaW4sIGhlbmNlIHRoZSBjdXN0b21cbiAgICogbG9naWMgYmVsb3cuXG4gICAqLyBjb25zdCBleGlzdGluZ1NlYXJjaCA9IHVybC5zZWFyY2g7XG4gICAgY29uc3QgcmF3UXVlcnkgPSBleGlzdGluZ1NlYXJjaC5zdGFydHNXaXRoKCc/JykgPyBleGlzdGluZ1NlYXJjaC5zbGljZSgxKSA6IGV4aXN0aW5nU2VhcmNoO1xuICAgIGNvbnN0IHBhaXJzID0gcmF3UXVlcnkuc3BsaXQoJyYnKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcGFpcnMucHVzaChfYXBwcm91dGVyaGVhZGVycy5ORVhUX1JTQ19VTklPTl9RVUVSWSArIFwiPVwiICsgdW5pcXVlQ2FjaGVLZXkpO1xuICAgIHVybC5zZWFyY2ggPSBwYWlycy5sZW5ndGggPyBcIj9cIiArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsIl9oYXNoIiwicmVxdWlyZSIsIl9hcHByb3V0ZXJoZWFkZXJzIiwidXJsIiwiaGVhZGVycyIsInVuaXF1ZUNhY2hlS2V5IiwiaGV4SGFzaCIsIk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJORVhUX1VSTCIsImpvaW4iLCJleGlzdGluZ1NlYXJjaCIsInNlYXJjaCIsInJhd1F1ZXJ5Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFpcnMiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJwdXNoIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJsZW5ndGgiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHFCQUFxQkMsbUJBQU9BLENBQUMsNkdBQTJCO0FBQzlELE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsMkdBQW1CO0FBQ2xELFNBQVNGLG1CQUFtQkksaUJBQWlCLEVBQUVDLGlCQUFpQjtJQUM1RCxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0Y7SUFDbEMsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0csZ0JBQWdCQyxpQkFBaUIsR0FBR0w7SUFDM0MseURBQXlEO0lBQ3pELElBQUksQ0FBQyxDQUFDLEdBQUdELGVBQWVPLFlBQVksRUFBRUYsZ0JBQWdCRixVQUFVO1FBQzVELGtHQUFrRztRQUNsRyxJQUFJSyxNQUFNQyxPQUFPLENBQUNKLGlCQUFpQjtZQUMvQixPQUFPO1FBQ1g7UUFDQSxzRUFBc0U7UUFDdEUsT0FBTztJQUNYO0lBQ0EsTUFBTUssY0FBY1Qsa0JBQWtCVSxNQUFNLElBQUk7SUFDaEQsSUFBSUQsYUFBYTtRQUNiLE9BQU87SUFDWDtJQUNBLE9BQU9iLG1CQUFtQixDQUFDLEdBQUdDLG1CQUFtQmMsd0JBQXdCLEVBQUVYLG9CQUFvQkcsY0FBYyxDQUFDRSxpQkFBaUI7QUFDbkk7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUW9CLE9BQU8sS0FBSyxjQUFlLE9BQU9wQixRQUFRb0IsT0FBTyxLQUFLLFlBQVlwQixRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEIsUUFBUW9CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QixPQUFPQyxjQUFjLENBQUNDLFFBQVFvQixPQUFPLEVBQUUsY0FBYztRQUFFbkIsT0FBTztJQUFLO0lBQ25FSCxPQUFPd0IsTUFBTSxDQUFDdEIsUUFBUW9CLE9BQU8sRUFBRXBCO0lBQy9CdUIsT0FBT3ZCLE9BQU8sR0FBR0EsUUFBUW9CLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3VsZEhhcmROYXZpZ2F0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ZsaWdodGRhdGFoZWxwZXJzID0gcmVxdWlyZShcIi4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnNcIik7XG5jb25zdCBfbWF0Y2hzZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRjaC1zZWdtZW50c1wiKTtcbmZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHNlZ21lbnQgbWF0Y2hlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudC5cbiAgICBpZiAoISgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGlmIChsYXN0U2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRIYXJkTmF2aWdhdGUoKDAsIF9mbGlnaHRkYXRhaGVscGVycy5nZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgpKGZsaWdodFNlZ21lbnRQYXRoKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiX2ZsaWdodGRhdGFoZWxwZXJzIiwicmVxdWlyZSIsIl9tYXRjaHNlZ21lbnRzIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsImN1cnJlbnRTZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsIm1hdGNoU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImxhc3RTZWdtZW50IiwibGVuZ3RoIiwiZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/segment-cache.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment — if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NavigationResultTag: function() {\n        return NavigationResultTag;\n    },\n    PrefetchPriority: function() {\n        return PrefetchPriority;\n    },\n    bumpPrefetchTask: function() {\n        return bumpPrefetchTask;\n    },\n    cancelPrefetchTask: function() {\n        return cancelPrefetchTask;\n    },\n    createCacheKey: function() {\n        return createCacheKey;\n    },\n    getCurrentCacheVersion: function() {\n        return getCurrentCacheVersion;\n    },\n    navigate: function() {\n        return navigate;\n    },\n    prefetch: function() {\n        return prefetch;\n    },\n    revalidateEntireCache: function() {\n        return revalidateEntireCache;\n    },\n    schedulePrefetchTask: function() {\n        return schedulePrefetchTask;\n    }\n});\nconst notEnabled = ()=>{\n    throw Object.defineProperty(new Error('Segment Cache experiment is not enabled. This is a bug in Next.js.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E654\",\n        enumerable: false,\n        configurable: true\n    });\n};\nconst prefetch =  false ? 0 : notEnabled;\nconst navigate =  false ? 0 : notEnabled;\nconst revalidateEntireCache =  false ? 0 : notEnabled;\nconst getCurrentCacheVersion =  false ? 0 : notEnabled;\nconst schedulePrefetchTask =  false ? 0 : notEnabled;\nconst cancelPrefetchTask =  false ? 0 : notEnabled;\nconst bumpPrefetchTask =  false ? 0 : notEnabled;\nconst createCacheKey =  false ? 0 : notEnabled;\nvar NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\nvar PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to any visible link that was hovered/touched at some point. This\n   * is not removed on mouse exit, because a link that was momentarily\n   * hovered is more likely to to be interacted with than one that was not.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=segment-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FBZ0I7QUFDakJBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBV047QUFDQSxTQUFTVyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJakIsT0FBT0MsY0FBYyxDQUFDZSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFiLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsa0JBQWtCO1FBQ2QsT0FBT0E7SUFDWDtJQUNBQyxrQkFBa0I7UUFDZCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsd0JBQXdCO1FBQ3BCLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7SUFDQUMsdUJBQXVCO1FBQ25CLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGFBQWE7SUFDZixNQUFNckIsT0FBT0MsY0FBYyxDQUFDLElBQUlxQixNQUFNLHVFQUF1RSxxQkFBcUI7UUFDOUhuQixPQUFPO1FBQ1BnQixZQUFZO1FBQ1pJLGNBQWM7SUFDbEI7QUFDSjtBQUNBLE1BQU1YLFdBQVdZLE1BQXVDLEdBQUcsQ0FLMUQsR0FBR0g7QUFDSixNQUFNVixXQUFXYSxNQUF1QyxHQUFHLENBSzFELEdBQUdIO0FBQ0osTUFBTVIsd0JBQXdCVyxNQUF1QyxHQUFHLENBS3ZFLEdBQUdIO0FBQ0osTUFBTVgseUJBQXlCYyxNQUF1QyxHQUFHLENBS3hFLEdBQUdIO0FBQ0osTUFBTVAsdUJBQXVCVSxNQUF1QyxHQUFHLENBS3RFLEdBQUdIO0FBQ0osTUFBTWIscUJBQXFCZ0IsTUFBdUMsR0FBRyxDQUtwRSxHQUFHSDtBQUNKLE1BQU1kLG1CQUFtQmlCLE1BQXVDLEdBQUcsQ0FLbEUsR0FBR0g7QUFDSixNQUFNWixpQkFBaUJlLE1BQXVDLEdBQUcsQ0FLaEUsR0FBR0g7QUFDSixJQUFJaEIsc0JBQXNCLFdBQVcsR0FBRyxTQUFTQSxtQkFBbUI7SUFDaEVBLG1CQUFtQixDQUFDQSxtQkFBbUIsQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ3REQSxtQkFBbUIsQ0FBQ0EsbUJBQW1CLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUMxREEsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDdkRBLG1CQUFtQixDQUFDQSxtQkFBbUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3hELE9BQU9BO0FBQ1gsRUFBRSxDQUFDO0FBQ0gsSUFBSUMsbUJBQW1CLFdBQVcsR0FBRyxTQUFTQSxnQkFBZ0I7SUFDMUQ7Ozs7R0FJRCxHQUFHQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNyRDs7R0FFRCxHQUFHQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUN0RDs7O0dBR0QsR0FBR0EsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekQsT0FBT0E7QUFDWCxFQUFFLENBQUM7QUFFSCxJQUFJLENBQUMsT0FBT0osUUFBUWdDLE9BQU8sS0FBSyxjQUFlLE9BQU9oQyxRQUFRZ0MsT0FBTyxLQUFLLFlBQVloQyxRQUFRZ0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPaEMsUUFBUWdDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktuQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFnQyxPQUFPLEVBQUUsY0FBYztRQUFFL0IsT0FBTztJQUFLO0lBQ25FSCxPQUFPb0MsTUFBTSxDQUFDbEMsUUFBUWdDLE9BQU8sRUFBRWhDO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFnQyxPQUFPO0FBQ2xDLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVudHJ5IHBvaW50IHRvIHRoZSBTZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEFsbCBjb2RlIHJlbGF0ZWQgdG8gdGhlIFNlZ21lbnQgQ2FjaGUgbGl2ZXMgYHNlZ21lbnQtY2FjaGUtaW1wbGAgZGlyZWN0b3J5LlxuICogQ2FsbGVycyBhY2Nlc3MgaXQgdGhyb3VnaCB0aGlzIGluZGlyZWN0aW9uLlxuICpcbiAqIFRoaXMgaXMgdG8gZW5zdXJlIHRoZSBjb2RlIGlzIGRlYWQgY29kZSBlbGltaW5hdGVkIGZyb20gdGhlIGJ1bmRsZSBpZiB0aGVcbiAqIGZsYWcgaXMgZGlzYWJsZWQuXG4gKlxuICogVE9ETzogVGhpcyBpcyBzdXBlciB0ZWRpb3VzLiBTaW5jZSBleHBlcmltZW50YWwgZmxhZ3MgYXJlIGFuIGVzc2VudGlhbCBwYXJ0XG4gKiBvZiBvdXIgd29ya2Zsb3csIHdlIHNob3VsZCBlc3RhYmxpc2ggYSBiZXR0ZXIgcGF0dGVybiBmb3IgZGVhZCBjb2RlXG4gKiBlbGltaW5hdGlvbi4gSWRlYWxseSBpdCB3b3VsZCBiZSBkb25lIGF0IHRoZSBidW5kbGVyIGxldmVsLCBsaWtlIGhvdyBSZWFjdCdzXG4gKiBidWlsZCBwcm9jZXNzIHdvcmtzLiBJbiB0aGUgUmVhY3QgcmVwbywgeW91IGRvbid0IGV2ZW4gbmVlZCB0byBhZGQgYW55IGV4dHJhXG4gKiBjb25maWd1cmF0aW9uIHBlciBleHBlcmltZW50IOKAlCBpZiB0aGUgY29kZSBpcyBub3QgcmVhY2hhYmxlLCBpdCBnZXRzIHN0cmlwcGVkXG4gKiBmcm9tIHRoZSBidWlsZCBhdXRvbWF0aWNhbGx5IGJ5IFJvbGx1cC4gT3IsIHNob3J0ZXIgdGVybSwgd2UgY291bGQgc3R1YiBvdXRcbiAqIGV4cGVyaW1lbnRhbCBtb2R1bGVzIGF0IGJ1aWxkIHRpbWUgYnkgdXBkYXRpbmcgdGhlIGJ1aWxkIGNvbmZpZywgaS5lLiBhIG1vcmVcbiAqIGF1dG9tYXRlZCB2ZXJzaW9uIG9mIHdoYXQgSSdtIGRvaW5nIG1hbnVhbGx5IGluIHRoaXMgZmlsZS5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5hdmlnYXRpb25SZXN1bHRUYWc6IG51bGwsXG4gICAgUHJlZmV0Y2hQcmlvcml0eTogbnVsbCxcbiAgICBidW1wUHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIGNhbmNlbFByZWZldGNoVGFzazogbnVsbCxcbiAgICBjcmVhdGVDYWNoZUtleTogbnVsbCxcbiAgICBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uOiBudWxsLFxuICAgIG5hdmlnYXRlOiBudWxsLFxuICAgIHByZWZldGNoOiBudWxsLFxuICAgIHJldmFsaWRhdGVFbnRpcmVDYWNoZTogbnVsbCxcbiAgICBzY2hlZHVsZVByZWZldGNoVGFzazogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBOYXZpZ2F0aW9uUmVzdWx0VGFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5hdmlnYXRpb25SZXN1bHRUYWc7XG4gICAgfSxcbiAgICBQcmVmZXRjaFByaW9yaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByZWZldGNoUHJpb3JpdHk7XG4gICAgfSxcbiAgICBidW1wUHJlZmV0Y2hUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJ1bXBQcmVmZXRjaFRhc2s7XG4gICAgfSxcbiAgICBjYW5jZWxQcmVmZXRjaFRhc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FuY2VsUHJlZmV0Y2hUYXNrO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FjaGVLZXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVLZXk7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50Q2FjaGVWZXJzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRDYWNoZVZlcnNpb247XG4gICAgfSxcbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0ZTtcbiAgICB9LFxuICAgIHByZWZldGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoO1xuICAgIH0sXG4gICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJldmFsaWRhdGVFbnRpcmVDYWNoZTtcbiAgICB9LFxuICAgIHNjaGVkdWxlUHJlZmV0Y2hUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlUHJlZmV0Y2hUYXNrO1xuICAgIH1cbn0pO1xuY29uc3Qgbm90RW5hYmxlZCA9ICgpPT57XG4gICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignU2VnbWVudCBDYWNoZSBleHBlcmltZW50IGlzIG5vdCBlbmFibGVkLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFNjU0XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn07XG5jb25zdCBwcmVmZXRjaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSA/IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3ByZWZldGNoJykucHJlZmV0Y2goLi4uYXJncyk7XG59IDogbm90RW5hYmxlZDtcbmNvbnN0IG5hdmlnYXRlID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFID8gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlKC4uLmFyZ3MpO1xufSA6IG5vdEVuYWJsZWQ7XG5jb25zdCByZXZhbGlkYXRlRW50aXJlQ2FjaGUgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgPyBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLnJldmFsaWRhdGVFbnRpcmVDYWNoZSguLi5hcmdzKTtcbn0gOiBub3RFbmFibGVkO1xuY29uc3QgZ2V0Q3VycmVudENhY2hlVmVyc2lvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSA/IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykuZ2V0Q3VycmVudENhY2hlVmVyc2lvbiguLi5hcmdzKTtcbn0gOiBub3RFbmFibGVkO1xuY29uc3Qgc2NoZWR1bGVQcmVmZXRjaFRhc2sgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgPyBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5zY2hlZHVsZVByZWZldGNoVGFzayguLi5hcmdzKTtcbn0gOiBub3RFbmFibGVkO1xuY29uc3QgY2FuY2VsUHJlZmV0Y2hUYXNrID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFID8gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuY2FuY2VsUHJlZmV0Y2hUYXNrKC4uLmFyZ3MpO1xufSA6IG5vdEVuYWJsZWQ7XG5jb25zdCBidW1wUHJlZmV0Y2hUYXNrID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFID8gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuYnVtcFByZWZldGNoVGFzayguLi5hcmdzKTtcbn0gOiBub3RFbmFibGVkO1xuY29uc3QgY3JlYXRlQ2FjaGVLZXkgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgPyBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZS1rZXknKS5jcmVhdGVDYWNoZUtleSguLi5hcmdzKTtcbn0gOiBub3RFbmFibGVkO1xudmFyIE5hdmlnYXRpb25SZXN1bHRUYWcgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5hdmlnYXRpb25SZXN1bHRUYWcpIHtcbiAgICBOYXZpZ2F0aW9uUmVzdWx0VGFnW05hdmlnYXRpb25SZXN1bHRUYWdbXCJNUEFcIl0gPSAwXSA9IFwiTVBBXCI7XG4gICAgTmF2aWdhdGlvblJlc3VsdFRhZ1tOYXZpZ2F0aW9uUmVzdWx0VGFnW1wiU3VjY2Vzc1wiXSA9IDFdID0gXCJTdWNjZXNzXCI7XG4gICAgTmF2aWdhdGlvblJlc3VsdFRhZ1tOYXZpZ2F0aW9uUmVzdWx0VGFnW1wiTm9PcFwiXSA9IDJdID0gXCJOb09wXCI7XG4gICAgTmF2aWdhdGlvblJlc3VsdFRhZ1tOYXZpZ2F0aW9uUmVzdWx0VGFnW1wiQXN5bmNcIl0gPSAzXSA9IFwiQXN5bmNcIjtcbiAgICByZXR1cm4gTmF2aWdhdGlvblJlc3VsdFRhZztcbn0oe30pO1xudmFyIFByZWZldGNoUHJpb3JpdHkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFByZWZldGNoUHJpb3JpdHkpIHtcbiAgICAvKipcbiAgICogQXNzaWduZWQgdG8gYW55IHZpc2libGUgbGluayB0aGF0IHdhcyBob3ZlcmVkL3RvdWNoZWQgYXQgc29tZSBwb2ludC4gVGhpc1xuICAgKiBpcyBub3QgcmVtb3ZlZCBvbiBtb3VzZSBleGl0LCBiZWNhdXNlIGEgbGluayB0aGF0IHdhcyBtb21lbnRhcmlseVxuICAgKiBob3ZlcmVkIGlzIG1vcmUgbGlrZWx5IHRvIHRvIGJlIGludGVyYWN0ZWQgd2l0aCB0aGFuIG9uZSB0aGF0IHdhcyBub3QuXG4gICAqLyBQcmVmZXRjaFByaW9yaXR5W1ByZWZldGNoUHJpb3JpdHlbXCJJbnRlbnRcIl0gPSAyXSA9IFwiSW50ZW50XCI7XG4gICAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaW9yaXR5IGZvciBwcmVmZXRjaCB0YXNrcy5cbiAgICovIFByZWZldGNoUHJpb3JpdHlbUHJlZmV0Y2hQcmlvcml0eVtcIkRlZmF1bHRcIl0gPSAxXSA9IFwiRGVmYXVsdFwiO1xuICAgIC8qKlxuICAgKiBBc3NpZ25lZCB0byB0YXNrcyB3aGVuIHRoZXkgc3Bhd24gbm9uLWJsb2NraW5nIGJhY2tncm91bmQgd29yaywgbGlrZVxuICAgKiByZXZhbGlkYXRpbmcgYSBwYXJ0aWFsbHkgY2FjaGVkIGVudHJ5IHRvIHNlZSBpZiBtb3JlIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgKi8gUHJlZmV0Y2hQcmlvcml0eVtQcmVmZXRjaFByaW9yaXR5W1wiQmFja2dyb3VuZFwiXSA9IDBdID0gXCJCYWNrZ3JvdW5kXCI7XG4gICAgcmV0dXJuIFByZWZldGNoUHJpb3JpdHk7XG59KHt9KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VnbWVudC1jYWNoZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiUHJlZmV0Y2hQcmlvcml0eSIsImJ1bXBQcmVmZXRjaFRhc2siLCJjYW5jZWxQcmVmZXRjaFRhc2siLCJjcmVhdGVDYWNoZUtleSIsImdldEN1cnJlbnRDYWNoZVZlcnNpb24iLCJuYXZpZ2F0ZSIsInByZWZldGNoIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwic2NoZWR1bGVQcmVmZXRjaFRhc2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJub3RFbmFibGVkIiwiRXJyb3IiLCJjb25maWd1cmFibGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/unauthorized.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/unauthorized.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unauthorized\", ({\n    enumerable: true,\n    get: function() {\n        return unauthorized;\n    }\n}));\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback/http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */ const DIGEST = \"\" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + \";401\";\nfunction unauthorized() {\n    if (true) {\n        throw Object.defineProperty(new Error(\"`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E411\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // eslint-disable-next-line no-throw-literal\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = DIGEST;\n    throw error;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=unauthorized.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdW5hdXRob3JpemVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxnREFBK0M7SUFDM0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxzQkFBc0JDLG1CQUFPQSxDQUFDLGdLQUE2QztBQUNqRixnQ0FBZ0M7QUFDaEM7Ozs7Ozs7Ozs7OztDQVlDLEdBQUcsTUFBTUMsU0FBUyxLQUFLRixvQkFBb0JHLDhCQUE4QixHQUFHO0FBQzdFLFNBQVNKO0lBQ0wsSUFBSSxJQUFnRCxFQUFFO1FBQ2xELE1BQU1OLE9BQU9DLGNBQWMsQ0FBQyxJQUFJYSxNQUFNLGdIQUFnSCxxQkFBcUI7WUFDdktYLE9BQU87WUFDUEMsWUFBWTtZQUNaVyxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSw0Q0FBNEM7SUFDNUMsTUFBTUMsUUFBUWhCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJYSxNQUFNTCxTQUFTLHFCQUFxQjtRQUN4RU4sT0FBTztRQUNQQyxZQUFZO1FBQ1pXLGNBQWM7SUFDbEI7SUFDQUMsTUFBTUMsTUFBTSxHQUFHUjtJQUNmLE1BQU1PO0FBQ1Y7QUFFQSxJQUFJLENBQUMsT0FBT2QsUUFBUWdCLE9BQU8sS0FBSyxjQUFlLE9BQU9oQixRQUFRZ0IsT0FBTyxLQUFLLFlBQVloQixRQUFRZ0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPaEIsUUFBUWdCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktuQixPQUFPQyxjQUFjLENBQUNDLFFBQVFnQixPQUFPLEVBQUUsY0FBYztRQUFFZixPQUFPO0lBQUs7SUFDbkVILE9BQU9vQixNQUFNLENBQUNsQixRQUFRZ0IsT0FBTyxFQUFFaEI7SUFDL0JtQixPQUFPbkIsT0FBTyxHQUFHQSxRQUFRZ0IsT0FBTztBQUNsQyxFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VuYXV0aG9yaXplZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuYXV0aG9yaXplZFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5hdXRob3JpemVkO1xuICAgIH1cbn0pO1xuY29uc3QgX2h0dHBhY2Nlc3NmYWxsYmFjayA9IHJlcXVpcmUoXCIuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrXCIpO1xuLy8gVE9ETzogQWRkIGB1bmF1dGhvcml6ZWRgIGRvY3Ncbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHJlbmRlciB0aGUgW3VuYXV0aG9yaXplZC5qcyBmaWxlXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9maWxlLWNvbnZlbnRpb25zL3VuYXV0aG9yaXplZClcbiAqIHdpdGhpbiBhIHJvdXRlIHNlZ21lbnQgYXMgd2VsbCBhcyBpbmplY3QgYSB0YWcuXG4gKlxuICogYHVuYXV0aG9yaXplZCgpYCBjYW4gYmUgdXNlZCBpblxuICogW1NlcnZlciBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc2VydmVyLWNvbXBvbmVudHMpLFxuICogW1JvdXRlIEhhbmRsZXJzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzKSwgYW5kXG4gKiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvc2VydmVyLWFjdGlvbnMtYW5kLW11dGF0aW9ucykuXG4gKlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVuYXV0aG9yaXplZGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bmF1dGhvcml6ZWQpXG4gKi8gY29uc3QgRElHRVNUID0gXCJcIiArIF9odHRwYWNjZXNzZmFsbGJhY2suSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFICsgXCI7NDAxXCI7XG5mdW5jdGlvbiB1bmF1dGhvcml6ZWQoKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfRVhQRVJJTUVOVEFMX0FVVEhfSU5URVJSVVBUUykge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKFwiYHVuYXV0aG9yaXplZCgpYCBpcyBleHBlcmltZW50YWwgYW5kIG9ubHkgYWxsb3dlZCB0byBiZSB1c2VkIHdoZW4gYGV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0c2AgaXMgZW5hYmxlZC5cIiksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwiRTQxMVwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgY29uc3QgZXJyb3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKERJR0VTVCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFMzk0XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBlcnJvci5kaWdlc3QgPSBESUdFU1Q7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuYXV0aG9yaXplZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidW5hdXRob3JpemVkIiwiX2h0dHBhY2Nlc3NmYWxsYmFjayIsInJlcXVpcmUiLCJESUdFU1QiLCJIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMiLCJFcnJvciIsImNvbmZpZ3VyYWJsZSIsImVycm9yIiwiZGlnZXN0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/unauthorized.js\n"));

/***/ })

}]);