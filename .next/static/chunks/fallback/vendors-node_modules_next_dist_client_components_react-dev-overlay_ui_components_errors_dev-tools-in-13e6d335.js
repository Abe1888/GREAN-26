"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_next_dist_client_components_react-dev-overlay_ui_components_errors_dev-tools-in-13e6d335"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js ***!
  \**************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMinimumLoadingTimeMultiple\", ({\n    enumerable: true,\n    get: function() {\n        return useMinimumLoadingTimeMultiple;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMinimumLoadingTimeMultiple(isLoadingTrigger, interval) {\n    if (interval === void 0) interval = 750;\n    const [isLoading, setIsLoading] = (0, _react.useState)(false);\n    const loadStartTimeRef = (0, _react.useRef)(null);\n    const timeoutIdRef = (0, _react.useRef)(null);\n    (0, _react.useEffect)(()=>{\n        // Clear any pending timeout to avoid overlap\n        if (timeoutIdRef.current) {\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = null;\n        }\n        if (isLoadingTrigger) {\n            // If we enter \"loading\" state, record start time if not already\n            if (loadStartTimeRef.current === null) {\n                loadStartTimeRef.current = Date.now();\n            }\n            setIsLoading(true);\n        } else {\n            // If we're exiting the \"loading\" state:\n            if (loadStartTimeRef.current === null) {\n                // No start time was recorded, so just stop loading immediately\n                setIsLoading(false);\n            } else {\n                // How long we've been \"loading\"\n                const timeDiff = Date.now() - loadStartTimeRef.current;\n                // Next multiple of `interval` after `timeDiff`\n                const nextMultiple = interval * Math.ceil(timeDiff / interval);\n                // Remaining time needed to reach that multiple\n                const remainingTime = nextMultiple - timeDiff;\n                if (remainingTime > 0) {\n                    // If not yet at that multiple, schedule the final step\n                    timeoutIdRef.current = setTimeout(()=>{\n                        setIsLoading(false);\n                        loadStartTimeRef.current = null;\n                    }, remainingTime);\n                } else {\n                    // We're already past the multiple boundary\n                    setIsLoading(false);\n                    loadStartTimeRef.current = null;\n                }\n            }\n        }\n        // Cleanup when effect is about to re-run or component unmounts\n        return ()=>{\n            if (timeoutIdRef.current) {\n                clearTimeout(timeoutIdRef.current);\n            }\n        };\n    }, [\n        isLoadingTrigger,\n        interval\n    ]);\n    return isLoading;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-minimum-loading-time-multiple.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdWkvY29tcG9uZW50cy9lcnJvcnMvZGV2LXRvb2xzLWluZGljYXRvci91c2UtbWluaW11bS1sb2FkaW5nLXRpbWUtbXVsdGlwbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlFQUFnRTtJQUM1REksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLFNBQVNGLDhCQUE4QkcsZ0JBQWdCLEVBQUVDLFFBQVE7SUFDN0QsSUFBSUEsYUFBYSxLQUFLLEdBQUdBLFdBQVc7SUFDcEMsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUcsQ0FBQyxHQUFHTCxPQUFPTSxRQUFRLEVBQUU7SUFDdkQsTUFBTUMsbUJBQW1CLENBQUMsR0FBR1AsT0FBT1EsTUFBTSxFQUFFO0lBQzVDLE1BQU1DLGVBQWUsQ0FBQyxHQUFHVCxPQUFPUSxNQUFNLEVBQUU7SUFDdkMsSUFBR1IsT0FBT1UsU0FBUyxFQUFFO1FBQ2xCLDZDQUE2QztRQUM3QyxJQUFJRCxhQUFhRSxPQUFPLEVBQUU7WUFDdEJDLGFBQWFILGFBQWFFLE9BQU87WUFDakNGLGFBQWFFLE9BQU8sR0FBRztRQUMzQjtRQUNBLElBQUlULGtCQUFrQjtZQUNsQixnRUFBZ0U7WUFDaEUsSUFBSUssaUJBQWlCSSxPQUFPLEtBQUssTUFBTTtnQkFDbkNKLGlCQUFpQkksT0FBTyxHQUFHRSxLQUFLQyxHQUFHO1lBQ3ZDO1lBQ0FULGFBQWE7UUFDakIsT0FBTztZQUNILHdDQUF3QztZQUN4QyxJQUFJRSxpQkFBaUJJLE9BQU8sS0FBSyxNQUFNO2dCQUNuQywrREFBK0Q7Z0JBQy9ETixhQUFhO1lBQ2pCLE9BQU87Z0JBQ0gsZ0NBQWdDO2dCQUNoQyxNQUFNVSxXQUFXRixLQUFLQyxHQUFHLEtBQUtQLGlCQUFpQkksT0FBTztnQkFDdEQsK0NBQStDO2dCQUMvQyxNQUFNSyxlQUFlYixXQUFXYyxLQUFLQyxJQUFJLENBQUNILFdBQVdaO2dCQUNyRCwrQ0FBK0M7Z0JBQy9DLE1BQU1nQixnQkFBZ0JILGVBQWVEO2dCQUNyQyxJQUFJSSxnQkFBZ0IsR0FBRztvQkFDbkIsdURBQXVEO29CQUN2RFYsYUFBYUUsT0FBTyxHQUFHUyxXQUFXO3dCQUM5QmYsYUFBYTt3QkFDYkUsaUJBQWlCSSxPQUFPLEdBQUc7b0JBQy9CLEdBQUdRO2dCQUNQLE9BQU87b0JBQ0gsMkNBQTJDO29CQUMzQ2QsYUFBYTtvQkFDYkUsaUJBQWlCSSxPQUFPLEdBQUc7Z0JBQy9CO1lBQ0o7UUFDSjtRQUNBLCtEQUErRDtRQUMvRCxPQUFPO1lBQ0gsSUFBSUYsYUFBYUUsT0FBTyxFQUFFO2dCQUN0QkMsYUFBYUgsYUFBYUUsT0FBTztZQUNyQztRQUNKO0lBQ0osR0FBRztRQUNDVDtRQUNBQztLQUNIO0lBQ0QsT0FBT0M7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPVCxRQUFRMEIsT0FBTyxLQUFLLGNBQWUsT0FBTzFCLFFBQVEwQixPQUFPLEtBQUssWUFBWTFCLFFBQVEwQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8xQixRQUFRMEIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzdCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTBCLE9BQU8sRUFBRSxjQUFjO1FBQUV6QixPQUFPO0lBQUs7SUFDbkVILE9BQU84QixNQUFNLENBQUM1QixRQUFRMEIsT0FBTyxFQUFFMUI7SUFDL0I2QixPQUFPN0IsT0FBTyxHQUFHQSxRQUFRMEIsT0FBTztBQUNsQyxFQUVBLDZEQUE2RCIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3VpL2NvbXBvbmVudHMvZXJyb3JzL2Rldi10b29scy1pbmRpY2F0b3IvdXNlLW1pbmltdW0tbG9hZGluZy10aW1lLW11bHRpcGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZU1pbmltdW1Mb2FkaW5nVGltZU11bHRpcGxlO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGUoaXNMb2FkaW5nVHJpZ2dlciwgaW50ZXJ2YWwpIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT09IHZvaWQgMCkgaW50ZXJ2YWwgPSA3NTA7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBsb2FkU3RhcnRUaW1lUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHRpbWVvdXRJZFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgdGltZW91dCB0byBhdm9pZCBvdmVybGFwXG4gICAgICAgIGlmICh0aW1lb3V0SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2FkaW5nVHJpZ2dlcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZW50ZXIgXCJsb2FkaW5nXCIgc3RhdGUsIHJlY29yZCBzdGFydCB0aW1lIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAobG9hZFN0YXJ0VGltZVJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9hZFN0YXJ0VGltZVJlZi5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGV4aXRpbmcgdGhlIFwibG9hZGluZ1wiIHN0YXRlOlxuICAgICAgICAgICAgaWYgKGxvYWRTdGFydFRpbWVSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHN0YXJ0IHRpbWUgd2FzIHJlY29yZGVkLCBzbyBqdXN0IHN0b3AgbG9hZGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvdyBsb25nIHdlJ3ZlIGJlZW4gXCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lRGlmZiA9IERhdGUubm93KCkgLSBsb2FkU3RhcnRUaW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBtdWx0aXBsZSBvZiBgaW50ZXJ2YWxgIGFmdGVyIGB0aW1lRGlmZmBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0TXVsdGlwbGUgPSBpbnRlcnZhbCAqIE1hdGguY2VpbCh0aW1lRGlmZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgdG8gcmVhY2ggdGhhdCBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBuZXh0TXVsdGlwbGUgLSB0aW1lRGlmZjtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IHlldCBhdCB0aGF0IG11bHRpcGxlLCBzY2hlZHVsZSB0aGUgZmluYWwgc3RlcFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkU3RhcnRUaW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCByZW1haW5pbmdUaW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBhbHJlYWR5IHBhc3QgdGhlIG11bHRpcGxlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRTdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFudXAgd2hlbiBlZmZlY3QgaXMgYWJvdXQgdG8gcmUtcnVuIG9yIGNvbXBvbmVudCB1bm1vdW50c1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpc0xvYWRpbmdUcmlnZ2VyLFxuICAgICAgICBpbnRlcnZhbFxuICAgIF0pO1xuICAgIHJldHVybiBpc0xvYWRpbmc7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1taW5pbXVtLWxvYWRpbmctdGltZS1tdWx0aXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGUiLCJfcmVhY3QiLCJyZXF1aXJlIiwiaXNMb2FkaW5nVHJpZ2dlciIsImludGVydmFsIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwidXNlU3RhdGUiLCJsb2FkU3RhcnRUaW1lUmVmIiwidXNlUmVmIiwidGltZW91dElkUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNsZWFyVGltZW91dCIsIkRhdGUiLCJub3ciLCJ0aW1lRGlmZiIsIm5leHRNdWx0aXBsZSIsIk1hdGgiLCJjZWlsIiwicmVtYWluaW5nVGltZSIsInNldFRpbWVvdXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js ***!
  \**********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    MENU_CURVE: function() {\n        return MENU_CURVE;\n    },\n    MENU_DURATION_MS: function() {\n        return MENU_DURATION_MS;\n    },\n    useClickOutside: function() {\n        return useClickOutside;\n    },\n    useFocusTrap: function() {\n        return useFocusTrap;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useFocusTrap(rootRef, triggerRef, active, onOpenFocus) {\n    (0, _react.useEffect)(()=>{\n        let rootNode = null;\n        function onTab(e) {\n            if (e.key !== 'Tab' || rootNode === null) {\n                return;\n            }\n            const [firstFocusableNode, lastFocusableNode] = getFocusableNodes(rootNode);\n            const activeElement = getActiveElement(rootNode);\n            if (e.shiftKey) {\n                if (activeElement === firstFocusableNode) {\n                    lastFocusableNode == null ? void 0 : lastFocusableNode.focus();\n                    e.preventDefault();\n                }\n            } else {\n                if (activeElement === lastFocusableNode) {\n                    firstFocusableNode == null ? void 0 : firstFocusableNode.focus();\n                    e.preventDefault();\n                }\n            }\n        }\n        const id = setTimeout(()=>{\n            // Grab this on next tick to ensure the content is mounted\n            rootNode = rootRef.current;\n            if (active) {\n                if (onOpenFocus) {\n                    onOpenFocus();\n                } else {\n                    rootNode == null ? void 0 : rootNode.focus();\n                }\n                rootNode == null ? void 0 : rootNode.addEventListener('keydown', onTab);\n            } else {\n                const activeElement = getActiveElement(rootNode);\n                // Only restore focus if the focus was previously on the content.\n                // This avoids us accidentally focusing on mount when the\n                // user could want to interact with their own app instead.\n                if (triggerRef && (rootNode == null ? void 0 : rootNode.contains(activeElement))) {\n                    var _triggerRef_current;\n                    (_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.focus();\n                }\n            }\n        });\n        return ()=>{\n            clearTimeout(id);\n            rootNode == null ? void 0 : rootNode.removeEventListener('keydown', onTab);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\nfunction getActiveElement(node) {\n    const root = node == null ? void 0 : node.getRootNode();\n    return root instanceof ShadowRoot ? root == null ? void 0 : root.activeElement : null;\n}\nfunction getFocusableNodes(node) {\n    const focusableElements = node.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n    if (!focusableElements) return [];\n    return [\n        focusableElements[0],\n        focusableElements[focusableElements.length - 1]\n    ];\n}\nfunction useClickOutside(rootRef, triggerRef, active, close) {\n    (0, _react.useEffect)(()=>{\n        if (!active) {\n            return;\n        }\n        function handleClickOutside(event) {\n            var _rootRef_current, _triggerRef_current;\n            if (!(((_rootRef_current = rootRef.current) == null ? void 0 : _rootRef_current.getBoundingClientRect()) ? event.clientX >= rootRef.current.getBoundingClientRect().left && event.clientX <= rootRef.current.getBoundingClientRect().right && event.clientY >= rootRef.current.getBoundingClientRect().top && event.clientY <= rootRef.current.getBoundingClientRect().bottom : false) && !(((_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.getBoundingClientRect()) ? event.clientX >= triggerRef.current.getBoundingClientRect().left && event.clientX <= triggerRef.current.getBoundingClientRect().right && event.clientY >= triggerRef.current.getBoundingClientRect().top && event.clientY <= triggerRef.current.getBoundingClientRect().bottom : false)) {\n                close();\n            }\n        }\n        function handleKeyDown(event) {\n            if (event.key === 'Escape') {\n                close();\n            }\n        }\n        document.addEventListener('mousedown', handleClickOutside);\n        document.addEventListener('keydown', handleKeyDown);\n        return ()=>{\n            document.removeEventListener('mousedown', handleClickOutside);\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\nconst MENU_DURATION_MS = 200;\nconst MENU_CURVE = 'cubic-bezier(0.175, 0.885, 0.32, 1.1)';\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdWkvY29tcG9uZW50cy9lcnJvcnMvZGV2LXRvb2xzLWluZGljYXRvci91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUtOO0FBQ0EsU0FBU0ssUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVgsT0FBT0MsY0FBYyxDQUFDUyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFQLFNBQVM7SUFDYkcsWUFBWTtRQUNSLE9BQU9BO0lBQ1g7SUFDQUMsa0JBQWtCO1FBQ2QsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGNBQWM7UUFDVixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM5QixTQUFTUixhQUFhUyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxXQUFXO0lBQ3pELElBQUdMLE9BQU9NLFNBQVMsRUFBRTtRQUNsQixJQUFJQyxXQUFXO1FBQ2YsU0FBU0MsTUFBTUMsQ0FBQztZQUNaLElBQUlBLEVBQUVDLEdBQUcsS0FBSyxTQUFTSCxhQUFhLE1BQU07Z0JBQ3RDO1lBQ0o7WUFDQSxNQUFNLENBQUNJLG9CQUFvQkMsa0JBQWtCLEdBQUdDLGtCQUFrQk47WUFDbEUsTUFBTU8sZ0JBQWdCQyxpQkFBaUJSO1lBQ3ZDLElBQUlFLEVBQUVPLFFBQVEsRUFBRTtnQkFDWixJQUFJRixrQkFBa0JILG9CQUFvQjtvQkFDdENDLHFCQUFxQixPQUFPLEtBQUssSUFBSUEsa0JBQWtCSyxLQUFLO29CQUM1RFIs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Q2lCLHFCQUFxQixHQUFHSyxHQUFHLElBQUlQLE1BQU1NLE9BQU8sSUFBSXZDLFdBQVdrQixPQUFPLENBQUNpQixxQkFBcUIsR0FBR00sTUFBTSxHQUFHLEtBQUksR0FBSTtnQkFDL3ZCVjtZQUNKO1FBQ0o7UUFDQSxTQUFTVyxjQUFjVCxLQUFLO1lBQ3hCLElBQUlBLE1BQU0xQixHQUFHLEtBQUssVUFBVTtnQkFDeEJ3QjtZQUNKO1FBQ0o7UUFDQVksU0FBU3hCLGdCQUFnQixDQUFDLGFBQWFhO1FBQ3ZDVyxTQUFTeEIsZ0JBQWdCLENBQUMsV0FBV3VCO1FBQ3JDLE9BQU87WUFDSEMsU0FBU3BCLG1CQUFtQixDQUFDLGFBQWFTO1lBQzFDVyxTQUFTcEIsbUJBQW1CLENBQUMsV0FBV21CO1FBQzVDO0lBQ0osdURBQXVEO0lBQ3ZELEdBQUc7UUFDQ3pDO0tBQ0g7QUFDTDtBQUNBLE1BQU1iLG1CQUFtQjtBQUN6QixNQUFNRCxhQUFhO0FBRW5CLElBQUksQ0FBQyxPQUFPSCxRQUFRNEQsT0FBTyxLQUFLLGNBQWUsT0FBTzVELFFBQVE0RCxPQUFPLEtBQUssWUFBWTVELFFBQVE0RCxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU81RCxRQUFRNEQsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySy9ELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRELE9BQU8sRUFBRSxjQUFjO1FBQUUzRCxPQUFPO0lBQUs7SUFDbkVILE9BQU9nRSxNQUFNLENBQUM5RCxRQUFRNEQsT0FBTyxFQUFFNUQ7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUTRELE9BQU87QUFDbEMsRUFFQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS91aS9jb21wb25lbnRzL2Vycm9ycy9kZXYtdG9vbHMtaW5kaWNhdG9yL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTUVOVV9DVVJWRTogbnVsbCxcbiAgICBNRU5VX0RVUkFUSU9OX01TOiBudWxsLFxuICAgIHVzZUNsaWNrT3V0c2lkZTogbnVsbCxcbiAgICB1c2VGb2N1c1RyYXA6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgTUVOVV9DVVJWRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNRU5VX0NVUlZFO1xuICAgIH0sXG4gICAgTUVOVV9EVVJBVElPTl9NUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNRU5VX0RVUkFUSU9OX01TO1xuICAgIH0sXG4gICAgdXNlQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUNsaWNrT3V0c2lkZTtcbiAgICB9LFxuICAgIHVzZUZvY3VzVHJhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VGb2N1c1RyYXA7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VGb2N1c1RyYXAocm9vdFJlZiwgdHJpZ2dlclJlZiwgYWN0aXZlLCBvbk9wZW5Gb2N1cykge1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgcm9vdE5vZGUgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBvblRhYihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgIT09ICdUYWInIHx8IHJvb3ROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0Rm9jdXNhYmxlTm9kZSwgbGFzdEZvY3VzYWJsZU5vZGVdID0gZ2V0Rm9jdXNhYmxlTm9kZXMocm9vdE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQocm9vdE5vZGUpO1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RGb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RGb2N1c2FibGVOb2RlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0Rm9jdXNhYmxlTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzYWJsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVOb2RlID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdEZvY3VzYWJsZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vIEdyYWIgdGhpcyBvbiBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoZSBjb250ZW50IGlzIG1vdW50ZWRcbiAgICAgICAgICAgIHJvb3ROb2RlID0gcm9vdFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbk9wZW5Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBvbk9wZW5Gb2N1cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiByb290Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uVGFiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQocm9vdE5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVzdG9yZSBmb2N1cyBpZiB0aGUgZm9jdXMgd2FzIHByZXZpb3VzbHkgb24gdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhdm9pZHMgdXMgYWNjaWRlbnRhbGx5IGZvY3VzaW5nIG9uIG1vdW50IHdoZW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdXNlciBjb3VsZCB3YW50IHRvIGludGVyYWN0IHdpdGggdGhlaXIgb3duIGFwcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyUmVmICYmIChyb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdHJpZ2dlclJlZl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAoX3RyaWdnZXJSZWZfY3VycmVudCA9IHRyaWdnZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmlnZ2VyUmVmX2N1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICByb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uVGFiKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAgIGNvbnN0IHJvb3QgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgcmV0dXJuIHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzYWJsZU5vZGVzKG5vZGUpIHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uLCBbaHJlZl0sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknKTtcbiAgICBpZiAoIWZvY3VzYWJsZUVsZW1lbnRzKSByZXR1cm4gW107XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudHNbMF0sXG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZUNsaWNrT3V0c2lkZShyb290UmVmLCB0cmlnZ2VyUmVmLCBhY3RpdmUsIGNsb3NlKSB7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3Jvb3RSZWZfY3VycmVudCwgX3RyaWdnZXJSZWZfY3VycmVudDtcbiAgICAgICAgICAgIGlmICghKCgoX3Jvb3RSZWZfY3VycmVudCA9IHJvb3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb290UmVmX2N1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID8gZXZlbnQuY2xpZW50WCA+PSByb290UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAmJiBldmVudC5jbGllbnRYIDw9IHJvb3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAmJiBldmVudC5jbGllbnRZID49IHJvb3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgJiYgZXZlbnQuY2xpZW50WSA8PSByb290UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIDogZmFsc2UpICYmICEoKChfdHJpZ2dlclJlZl9jdXJyZW50ID0gdHJpZ2dlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RyaWdnZXJSZWZfY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPyBldmVudC5jbGllbnRYID49IHRyaWdnZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICYmIGV2ZW50LmNsaWVudFggPD0gdHJpZ2dlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ICYmIGV2ZW50LmNsaWVudFkgPj0gdHJpZ2dlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAmJiBldmVudC5jbGllbnRZIDw9IHRyaWdnZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gOiBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVcbiAgICBdKTtcbn1cbmNvbnN0IE1FTlVfRFVSQVRJT05fTVMgPSAyMDA7XG5jb25zdCBNRU5VX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMSknO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJNRU5VX0NVUlZFIiwiTUVOVV9EVVJBVElPTl9NUyIsInVzZUNsaWNrT3V0c2lkZSIsInVzZUZvY3VzVHJhcCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9yZWFjdCIsInJlcXVpcmUiLCJyb290UmVmIiwidHJpZ2dlclJlZiIsImFjdGl2ZSIsIm9uT3BlbkZvY3VzIiwidXNlRWZmZWN0Iiwicm9vdE5vZGUiLCJvblRhYiIsImUiLCJrZXkiLCJmaXJzdEZvY3VzYWJsZU5vZGUiLCJsYXN0Rm9jdXNhYmxlTm9kZSIsImdldEZvY3VzYWJsZU5vZGVzIiwiYWN0aXZlRWxlbWVudCIsImdldEFjdGl2ZUVsZW1lbnQiLCJzaGlmdEtleSIsImZvY3VzIiwicHJldmVudERlZmF1bHQiLCJpZCIsInNldFRpbWVvdXQiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbnRhaW5zIiwiX3RyaWdnZXJSZWZfY3VycmVudCIsImNsZWFyVGltZW91dCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJub2RlIiwicm9vdCIsImdldFJvb3ROb2RlIiwiU2hhZG93Um9vdCIsImZvY3VzYWJsZUVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImNsb3NlIiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJfcm9vdFJlZl9jdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJyaWdodCIsImNsaWVudFkiLCJ0b3AiLCJib3R0b20iLCJoYW5kbGVLZXlEb3duIiwiZG9jdW1lbnQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js ***!
  \**************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMinimumLoadingTimeMultiple\", ({\n    enumerable: true,\n    get: function() {\n        return useMinimumLoadingTimeMultiple;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nfunction useMinimumLoadingTimeMultiple(isLoadingTrigger, interval) {\n    if (interval === void 0) interval = 750;\n    const [isLoading, setIsLoading] = (0, _react.useState)(false);\n    const loadStartTimeRef = (0, _react.useRef)(null);\n    const timeoutIdRef = (0, _react.useRef)(null);\n    (0, _react.useEffect)(()=>{\n        // Clear any pending timeout to avoid overlap\n        if (timeoutIdRef.current) {\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = null;\n        }\n        if (isLoadingTrigger) {\n            // If we enter \"loading\" state, record start time if not already\n            if (loadStartTimeRef.current === null) {\n                loadStartTimeRef.current = Date.now();\n            }\n            setIsLoading(true);\n        } else {\n            // If we're exiting the \"loading\" state:\n            if (loadStartTimeRef.current === null) {\n                // No start time was recorded, so just stop loading immediately\n                setIsLoading(false);\n            } else {\n                // How long we've been \"loading\"\n                const timeDiff = Date.now() - loadStartTimeRef.current;\n                // Next multiple of `interval` after `timeDiff`\n                const nextMultiple = interval * Math.ceil(timeDiff / interval);\n                // Remaining time needed to reach that multiple\n                const remainingTime = nextMultiple - timeDiff;\n                if (remainingTime > 0) {\n                    // If not yet at that multiple, schedule the final step\n                    timeoutIdRef.current = setTimeout(()=>{\n                        setIsLoading(false);\n                        loadStartTimeRef.current = null;\n                    }, remainingTime);\n                } else {\n                    // We're already past the multiple boundary\n                    setIsLoading(false);\n                    loadStartTimeRef.current = null;\n                }\n            }\n        }\n        // Cleanup when effect is about to re-run or component unmounts\n        return ()=>{\n            if (timeoutIdRef.current) {\n                clearTimeout(timeoutIdRef.current);\n            }\n        };\n    }, [\n        isLoadingTrigger,\n        interval\n    ]);\n    return isLoading;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-minimum-loading-time-multiple.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdWkvY29tcG9uZW50cy9lcnJvcnMvZGV2LXRvb2xzLWluZGljYXRvci91c2UtbWluaW11bS1sb2FkaW5nLXRpbWUtbXVsdGlwbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlFQUFnRTtJQUM1REksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLGdFQUFPO0FBQzlCLFNBQVNGLDhCQUE4QkcsZ0JBQWdCLEVBQUVDLFFBQVE7SUFDN0QsSUFBSUEsYUFBYSxLQUFLLEdBQUdBLFdBQVc7SUFDcEMsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUcsQ0FBQyxHQUFHTCxPQUFPTSxRQUFRLEVBQUU7SUFDdkQsTUFBTUMsbUJBQW1CLENBQUMsR0FBR1AsT0FBT1EsTUFBTSxFQUFFO0lBQzVDLE1BQU1DLGVBQWUsQ0FBQyxHQUFHVCxPQUFPUSxNQUFNLEVBQUU7SUFDdkMsSUFBR1IsT0FBT1UsU0FBUyxFQUFFO1FBQ2xCLDZDQUE2QztRQUM3QyxJQUFJRCxhQUFhRSxPQUFPLEVBQUU7WUFDdEJDLGFBQWFILGFBQWFFLE9BQU87WUFDakNGLGFBQWFFLE9BQU8sR0FBRztRQUMzQjtRQUNBLElBQUlULGtCQUFrQjtZQUNsQixnRUFBZ0U7WUFDaEUsSUFBSUssaUJBQWlCSSxPQUFPLEtBQUssTUFBTTtnQkFDbkNKLGlCQUFpQkksT0FBTyxHQUFHRSxLQUFLQyxHQUFHO1lBQ3ZDO1lBQ0FULGFBQWE7UUFDakIsT0FBTztZQUNILHdDQUF3QztZQUN4QyxJQUFJRSxpQkFBaUJJLE9BQU8sS0FBSyxNQUFNO2dCQUNuQywrREFBK0Q7Z0JBQy9ETixhQUFhO1lBQ2pCLE9BQU87Z0JBQ0gsZ0NBQWdDO2dCQUNoQyxNQUFNVSxXQUFXRixLQUFLQyxHQUFHLEtBQUtQLGlCQUFpQkksT0FBTztnQkFDdEQsK0NBQStDO2dCQUMvQyxNQUFNSyxlQUFlYixXQUFXYyxLQUFLQyxJQUFJLENBQUNILFdBQVdaO2dCQUNyRCwrQ0FBK0M7Z0JBQy9DLE1BQU1nQixnQkFBZ0JILGVBQWVEO2dCQUNyQyxJQUFJSSxnQkFBZ0IsR0FBRztvQkFDbkIsdURBQXVEO29CQUN2RFYsYUFBYUUsT0FBTyxHQUFHUyxXQUFXO3dCQUM5QmYsYUFBYTt3QkFDYkUsaUJBQWlCSSxPQUFPLEdBQUc7b0JBQy9CLEdBQUdRO2dCQUNQLE9BQU87b0JBQ0gsMkNBQTJDO29CQUMzQ2QsYUFBYTtvQkFDYkUsaUJBQWlCSSxPQUFPLEdBQUc7Z0JBQy9CO1lBQ0o7UUFDSjtRQUNBLCtEQUErRDtRQUMvRCxPQUFPO1lBQ0gsSUFBSUYsYUFBYUUsT0FBTyxFQUFFO2dCQUN0QkMsYUFBYUgsYUFBYUUsT0FBTztZQUNyQztRQUNKO0lBQ0osR0FBRztRQUNDVDtRQUNBQztLQUNIO0lBQ0QsT0FBT0M7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPVCxRQUFRMEIsT0FBTyxLQUFLLGNBQWUsT0FBTzFCLFFBQVEwQixPQUFPLEtBQUssWUFBWTFCLFFBQVEwQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8xQixRQUFRMEIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzdCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTBCLE9BQU8sRUFBRSxjQUFjO1FBQUV6QixPQUFPO0lBQUs7SUFDbkVILE9BQU84QixNQUFNLENBQUM1QixRQUFRMEIsT0FBTyxFQUFFMUI7SUFDL0I2QixPQUFPN0IsT0FBTyxHQUFHQSxRQUFRMEIsT0FBTztBQUNsQyxFQUVBLDZEQUE2RCIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3VpL2NvbXBvbmVudHMvZXJyb3JzL2Rldi10b29scy1pbmRpY2F0b3IvdXNlLW1pbmltdW0tbG9hZGluZy10aW1lLW11bHRpcGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZU1pbmltdW1Mb2FkaW5nVGltZU11bHRpcGxlO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gdXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGUoaXNMb2FkaW5nVHJpZ2dlciwgaW50ZXJ2YWwpIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT09IHZvaWQgMCkgaW50ZXJ2YWwgPSA3NTA7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBsb2FkU3RhcnRUaW1lUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHRpbWVvdXRJZFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgdGltZW91dCB0byBhdm9pZCBvdmVybGFwXG4gICAgICAgIGlmICh0aW1lb3V0SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2FkaW5nVHJpZ2dlcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZW50ZXIgXCJsb2FkaW5nXCIgc3RhdGUsIHJlY29yZCBzdGFydCB0aW1lIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAobG9hZFN0YXJ0VGltZVJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9hZFN0YXJ0VGltZVJlZi5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGV4aXRpbmcgdGhlIFwibG9hZGluZ1wiIHN0YXRlOlxuICAgICAgICAgICAgaWYgKGxvYWRTdGFydFRpbWVSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIHN0YXJ0IHRpbWUgd2FzIHJlY29yZGVkLCBzbyBqdXN0IHN0b3AgbG9hZGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvdyBsb25nIHdlJ3ZlIGJlZW4gXCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lRGlmZiA9IERhdGUubm93KCkgLSBsb2FkU3RhcnRUaW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCBtdWx0aXBsZSBvZiBgaW50ZXJ2YWxgIGFmdGVyIGB0aW1lRGlmZmBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0TXVsdGlwbGUgPSBpbnRlcnZhbCAqIE1hdGguY2VpbCh0aW1lRGlmZiAvIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgdG8gcmVhY2ggdGhhdCBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBuZXh0TXVsdGlwbGUgLSB0aW1lRGlmZjtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IHlldCBhdCB0aGF0IG11bHRpcGxlLCBzY2hlZHVsZSB0aGUgZmluYWwgc3RlcFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkU3RhcnRUaW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCByZW1haW5pbmdUaW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBhbHJlYWR5IHBhc3QgdGhlIG11bHRpcGxlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRTdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFudXAgd2hlbiBlZmZlY3QgaXMgYWJvdXQgdG8gcmUtcnVuIG9yIGNvbXBvbmVudCB1bm1vdW50c1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpc0xvYWRpbmdUcmlnZ2VyLFxuICAgICAgICBpbnRlcnZhbFxuICAgIF0pO1xuICAgIHJldHVybiBpc0xvYWRpbmc7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1taW5pbXVtLWxvYWRpbmctdGltZS1tdWx0aXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidXNlTWluaW11bUxvYWRpbmdUaW1lTXVsdGlwbGUiLCJfcmVhY3QiLCJyZXF1aXJlIiwiaXNMb2FkaW5nVHJpZ2dlciIsImludGVydmFsIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwidXNlU3RhdGUiLCJsb2FkU3RhcnRUaW1lUmVmIiwidXNlUmVmIiwidGltZW91dElkUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNsZWFyVGltZW91dCIsIkRhdGUiLCJub3ciLCJ0aW1lRGlmZiIsIm5leHRNdWx0aXBsZSIsIk1hdGgiLCJjZWlsIiwicmVtYWluaW5nVGltZSIsInNldFRpbWVvdXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js ***!
  \**********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    MENU_CURVE: function() {\n        return MENU_CURVE;\n    },\n    MENU_DURATION_MS: function() {\n        return MENU_DURATION_MS;\n    },\n    useClickOutside: function() {\n        return useClickOutside;\n    },\n    useFocusTrap: function() {\n        return useFocusTrap;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nfunction useFocusTrap(rootRef, triggerRef, active, onOpenFocus) {\n    (0, _react.useEffect)(()=>{\n        let rootNode = null;\n        function onTab(e) {\n            if (e.key !== 'Tab' || rootNode === null) {\n                return;\n            }\n            const [firstFocusableNode, lastFocusableNode] = getFocusableNodes(rootNode);\n            const activeElement = getActiveElement(rootNode);\n            if (e.shiftKey) {\n                if (activeElement === firstFocusableNode) {\n                    lastFocusableNode == null ? void 0 : lastFocusableNode.focus();\n                    e.preventDefault();\n                }\n            } else {\n                if (activeElement === lastFocusableNode) {\n                    firstFocusableNode == null ? void 0 : firstFocusableNode.focus();\n                    e.preventDefault();\n                }\n            }\n        }\n        const id = setTimeout(()=>{\n            // Grab this on next tick to ensure the content is mounted\n            rootNode = rootRef.current;\n            if (active) {\n                if (onOpenFocus) {\n                    onOpenFocus();\n                } else {\n                    rootNode == null ? void 0 : rootNode.focus();\n                }\n                rootNode == null ? void 0 : rootNode.addEventListener('keydown', onTab);\n            } else {\n                const activeElement = getActiveElement(rootNode);\n                // Only restore focus if the focus was previously on the content.\n                // This avoids us accidentally focusing on mount when the\n                // user could want to interact with their own app instead.\n                if (triggerRef && (rootNode == null ? void 0 : rootNode.contains(activeElement))) {\n                    var _triggerRef_current;\n                    (_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.focus();\n                }\n            }\n        });\n        return ()=>{\n            clearTimeout(id);\n            rootNode == null ? void 0 : rootNode.removeEventListener('keydown', onTab);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\nfunction getActiveElement(node) {\n    const root = node == null ? void 0 : node.getRootNode();\n    return root instanceof ShadowRoot ? root == null ? void 0 : root.activeElement : null;\n}\nfunction getFocusableNodes(node) {\n    const focusableElements = node.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n    if (!focusableElements) return [];\n    return [\n        focusableElements[0],\n        focusableElements[focusableElements.length - 1]\n    ];\n}\nfunction useClickOutside(rootRef, triggerRef, active, close) {\n    (0, _react.useEffect)(()=>{\n        if (!active) {\n            return;\n        }\n        function handleClickOutside(event) {\n            var _rootRef_current, _triggerRef_current;\n            if (!(((_rootRef_current = rootRef.current) == null ? void 0 : _rootRef_current.getBoundingClientRect()) ? event.clientX >= rootRef.current.getBoundingClientRect().left && event.clientX <= rootRef.current.getBoundingClientRect().right && event.clientY >= rootRef.current.getBoundingClientRect().top && event.clientY <= rootRef.current.getBoundingClientRect().bottom : false) && !(((_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.getBoundingClientRect()) ? event.clientX >= triggerRef.current.getBoundingClientRect().left && event.clientX <= triggerRef.current.getBoundingClientRect().right && event.clientY >= triggerRef.current.getBoundingClientRect().top && event.clientY <= triggerRef.current.getBoundingClientRect().bottom : false)) {\n                close();\n            }\n        }\n        function handleKeyDown(event) {\n            if (event.key === 'Escape') {\n                close();\n            }\n        }\n        document.addEventListener('mousedown', handleClickOutside);\n        document.addEventListener('keydown', handleKeyDown);\n        return ()=>{\n            document.removeEventListener('mousedown', handleClickOutside);\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\nconst MENU_DURATION_MS = 200;\nconst MENU_CURVE = 'cubic-bezier(0.175, 0.885, 0.32, 1.1)';\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvdWkvY29tcG9uZW50cy9lcnJvcnMvZGV2LXRvb2xzLWluZGljYXRvci91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUtOO0FBQ0EsU0FBU0ssUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVgsT0FBT0MsY0FBYyxDQUFDUyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFQLFNBQVM7SUFDYkcsWUFBWTtRQUNSLE9BQU9BO0lBQ1g7SUFDQUMsa0JBQWtCO1FBQ2QsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGNBQWM7UUFDVixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxTQUFTQyxtQkFBT0EsQ0FBQyxnRUFBTztBQUM5QixTQUFTUixhQUFhUyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxXQUFXO0lBQ3pELElBQUdMLE9BQU9NLFNBQVMsRUFBRTtRQUNsQixJQUFJQyxXQUFXO1FBQ2YsU0FBU0MsTUFBTUMsQ0FBQztZQUNaLElBQUlBLEVBQUVDLEdBQUcsS0FBSyxTQUFTSCxhQUFhLE1BQU07Z0JBQ3RDO1lBQ0o7WUFDQSxNQUFNLENBQUNJLG9CQUFvQkMsa0JBQWtCLEdBQUdDLGtCQUFrQk47WUFDbEUsTUFBTU8sZ0JBQWdCQyxpQkFBaUJSO1lBQ3ZDLElBQUlFLEVBQUVPLFFBQVEsRUFBRTtnQkFDWixJQUFJRixrQkFBa0JILG9CQUFvQjtvQkFDdENDLHFCQUFxQixPQUFPLEtBQUssSUFBSUEsa0JBQWtCSyxLQUFLO29CQUM1RFIs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Q2lCLHFCQUFxQixHQUFHSyxHQUFHLElBQUlQLE1BQU1NLE9BQU8sSUFBSXZDLFdBQVdrQixPQUFPLENBQUNpQixxQkFBcUIsR0FBR00sTUFBTSxHQUFHLEtBQUksR0FBSTtnQkFDL3ZCVjtZQUNKO1FBQ0o7UUFDQSxTQUFTVyxjQUFjVCxLQUFLO1lBQ3hCLElBQUlBLE1BQU0xQixHQUFHLEtBQUssVUFBVTtnQkFDeEJ3QjtZQUNKO1FBQ0o7UUFDQVksU0FBU3hCLGdCQUFnQixDQUFDLGFBQWFhO1FBQ3ZDVyxTQUFTeEIsZ0JBQWdCLENBQUMsV0FBV3VCO1FBQ3JDLE9BQU87WUFDSEMsU0FBU3BCLG1CQUFtQixDQUFDLGFBQWFTO1lBQzFDVyxTQUFTcEIsbUJBQW1CLENBQUMsV0FBV21CO1FBQzVDO0lBQ0osdURBQXVEO0lBQ3ZELEdBQUc7UUFDQ3pDO0tBQ0g7QUFDTDtBQUNBLE1BQU1iLG1CQUFtQjtBQUN6QixNQUFNRCxhQUFhO0FBRW5CLElBQUksQ0FBQyxPQUFPSCxRQUFRNEQsT0FBTyxLQUFLLGNBQWUsT0FBTzVELFFBQVE0RCxPQUFPLEtBQUssWUFBWTVELFFBQVE0RCxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU81RCxRQUFRNEQsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySy9ELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRELE9BQU8sRUFBRSxjQUFjO1FBQUUzRCxPQUFPO0lBQUs7SUFDbkVILE9BQU9nRSxNQUFNLENBQUM5RCxRQUFRNEQsT0FBTyxFQUFFNUQ7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUTRELE9BQU87QUFDbEMsRUFFQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS91aS9jb21wb25lbnRzL2Vycm9ycy9kZXYtdG9vbHMtaW5kaWNhdG9yL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTUVOVV9DVVJWRTogbnVsbCxcbiAgICBNRU5VX0RVUkFUSU9OX01TOiBudWxsLFxuICAgIHVzZUNsaWNrT3V0c2lkZTogbnVsbCxcbiAgICB1c2VGb2N1c1RyYXA6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgTUVOVV9DVVJWRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNRU5VX0NVUlZFO1xuICAgIH0sXG4gICAgTUVOVV9EVVJBVElPTl9NUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNRU5VX0RVUkFUSU9OX01TO1xuICAgIH0sXG4gICAgdXNlQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUNsaWNrT3V0c2lkZTtcbiAgICB9LFxuICAgIHVzZUZvY3VzVHJhcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VGb2N1c1RyYXA7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiB1c2VGb2N1c1RyYXAocm9vdFJlZiwgdHJpZ2dlclJlZiwgYWN0aXZlLCBvbk9wZW5Gb2N1cykge1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgcm9vdE5vZGUgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBvblRhYihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgIT09ICdUYWInIHx8IHJvb3ROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0Rm9jdXNhYmxlTm9kZSwgbGFzdEZvY3VzYWJsZU5vZGVdID0gZ2V0Rm9jdXNhYmxlTm9kZXMocm9vdE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQocm9vdE5vZGUpO1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RGb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RGb2N1c2FibGVOb2RlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0Rm9jdXNhYmxlTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzYWJsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVOb2RlID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdEZvY3VzYWJsZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vIEdyYWIgdGhpcyBvbiBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoZSBjb250ZW50IGlzIG1vdW50ZWRcbiAgICAgICAgICAgIHJvb3ROb2RlID0gcm9vdFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbk9wZW5Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBvbk9wZW5Gb2N1cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiByb290Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uVGFiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQocm9vdE5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVzdG9yZSBmb2N1cyBpZiB0aGUgZm9jdXMgd2FzIHByZXZpb3VzbHkgb24gdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhdm9pZHMgdXMgYWNjaWRlbnRhbGx5IGZvY3VzaW5nIG9uIG1vdW50IHdoZW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdXNlciBjb3VsZCB3YW50IHRvIGludGVyYWN0IHdpdGggdGhlaXIgb3duIGFwcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyUmVmICYmIChyb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdHJpZ2dlclJlZl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAoX3RyaWdnZXJSZWZfY3VycmVudCA9IHRyaWdnZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmlnZ2VyUmVmX2N1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICByb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uVGFiKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAgIGNvbnN0IHJvb3QgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgcmV0dXJuIHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzYWJsZU5vZGVzKG5vZGUpIHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uLCBbaHJlZl0sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknKTtcbiAgICBpZiAoIWZvY3VzYWJsZUVsZW1lbnRzKSByZXR1cm4gW107XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudHNbMF0sXG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZUNsaWNrT3V0c2lkZShyb290UmVmLCB0cmlnZ2VyUmVmLCBhY3RpdmUsIGNsb3NlKSB7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3Jvb3RSZWZfY3VycmVudCwgX3RyaWdnZXJSZWZfY3VycmVudDtcbiAgICAgICAgICAgIGlmICghKCgoX3Jvb3RSZWZfY3VycmVudCA9IHJvb3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb290UmVmX2N1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID8gZXZlbnQuY2xpZW50WCA+PSByb290UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAmJiBldmVudC5jbGllbnRYIDw9IHJvb3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAmJiBldmVudC5jbGllbnRZID49IHJvb3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgJiYgZXZlbnQuY2xpZW50WSA8PSByb290UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIDogZmFsc2UpICYmICEoKChfdHJpZ2dlclJlZl9jdXJyZW50ID0gdHJpZ2dlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RyaWdnZXJSZWZfY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPyBldmVudC5jbGllbnRYID49IHRyaWdnZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICYmIGV2ZW50LmNsaWVudFggPD0gdHJpZ2dlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ICYmIGV2ZW50LmNsaWVudFkgPj0gdHJpZ2dlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAmJiBldmVudC5jbGllbnRZIDw9IHRyaWdnZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gOiBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVcbiAgICBdKTtcbn1cbmNvbnN0IE1FTlVfRFVSQVRJT05fTVMgPSAyMDA7XG5jb25zdCBNRU5VX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMSknO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJNRU5VX0NVUlZFIiwiTUVOVV9EVVJBVElPTl9NUyIsInVzZUNsaWNrT3V0c2lkZSIsInVzZUZvY3VzVHJhcCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9yZWFjdCIsInJlcXVpcmUiLCJyb290UmVmIiwidHJpZ2dlclJlZiIsImFjdGl2ZSIsIm9uT3BlbkZvY3VzIiwidXNlRWZmZWN0Iiwicm9vdE5vZGUiLCJvblRhYiIsImUiLCJrZXkiLCJmaXJzdEZvY3VzYWJsZU5vZGUiLCJsYXN0Rm9jdXNhYmxlTm9kZSIsImdldEZvY3VzYWJsZU5vZGVzIiwiYWN0aXZlRWxlbWVudCIsImdldEFjdGl2ZUVsZW1lbnQiLCJzaGlmdEtleSIsImZvY3VzIiwicHJldmVudERlZmF1bHQiLCJpZCIsInNldFRpbWVvdXQiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbnRhaW5zIiwiX3RyaWdnZXJSZWZfY3VycmVudCIsImNsZWFyVGltZW91dCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJub2RlIiwicm9vdCIsImdldFJvb3ROb2RlIiwiU2hhZG93Um9vdCIsImZvY3VzYWJsZUVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImNsb3NlIiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJfcm9vdFJlZl9jdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJyaWdodCIsImNsaWVudFkiLCJ0b3AiLCJib3R0b20iLCJoYW5kbGVLZXlEb3duIiwiZG9jdW1lbnQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js\n"));

/***/ })

}]);